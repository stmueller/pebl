PEBL EMSCRIPTEN FILE UPLOAD - CURRENT PROGRESS
==============================================
Date: 2025-10-13

PROBLEM STATEMENT
-----------------
Implementing HTTP file upload functionality for PEBL's Emscripten/WebAssembly build.
The native Linux build uses libcurl and works perfectly. The Emscripten build needs
to use the browser's Fetch API (emscripten_fetch) instead.

WHAT WE'RE TRYING TO FIX
------------------------
File: src/utility/PEBLHTTP.cpp
Function: PostMulti() in the PEBL_FETCH section (lines ~1178-1370)

This function needs to:
1. Build a multipart/form-data HTTP POST request body
2. Include form parameters (user_name, upload_password, taskname, subnum)
3. Include the uploaded file content
4. Send to server via emscripten_fetch API
5. Wait for response and return status

PROGRESS MADE
-------------
✅ Added http:// protocol to URLs (emscripten_fetch requires full URLs)
✅ Fixed string lifetime issues (temporary strings were being destroyed)
✅ Moved parameters from URL query string to POST body (matching CURL behavior)
✅ Built proper multipart/form-data format with boundary delimiters
✅ Added CORS headers to PHP server (Access-Control-Allow-Origin: *)
✅ Request reaches server successfully (HTTP 200 response)

CURRENT BLOCKER
---------------
❌ POST request body is NOT being sent to the server

Server logs show:
- $_POST = empty array
- $_FILES = empty array
- Raw input length: 0
- Content-Type header is correct
- HTTP 200 response (request arrives, just without body)

Browser behavior:
- Synchronous mode: emscripten_fetch() returns NULL (CORS blocks sync cross-origin POST)
- Async + WAITABLE mode: Returns handle but readyState stays 0 (UNSENT)
- Async + busy-wait: Latest attempt, didn't work (need to verify Asyncify is enabled)

ROOT CAUSE
----------
Modern browsers heavily restrict cross-origin synchronous requests, especially with POST bodies.
PEBL code expects synchronous behavior (call function, wait for result, return).
The async nature of browser Fetch API conflicts with PEBL's synchronous execution model.

TECHNICAL DETAILS
-----------------
Test file: upload-battery/test/testUpload.pbl
- Creates dummy CSV file (404 bytes of data)
- Calls PostHTTPFile() which calls PEBLHTTP::PostMulti()
- Sends to obereed.net/PDS/uploadPEBL.php

Multipart body structure (808 bytes total):
1. Form parameters as multipart fields (user_name, upload_password, etc.)
2. File upload field (name="fileToUpload", filename="DUMMY-1043.csv")
3. Additional metadata fields (filename, submit)
4. Proper boundary delimiters

PHP server expectations:
- $_POST should contain: user_name, upload_password, taskname, subnum
- $_FILES["fileToUpload"] should contain the uploaded file
- User authentication via SQLite database (username/password hash check)

ATTEMPTED SOLUTIONS
-------------------
1. SYNCHRONOUS mode: Blocked by browser CORS policy
2. WAITABLE mode + emscripten_fetch_wait(): Request never sent (readyState=0)
3. ASYNC mode + busy-wait with emscripten_sleep(): Latest attempt (needs Asyncify)

NEXT STEPS TO TRY
-----------------

OPTION 1: Verify Asyncify Configuration
- Check Makefile em-opt target has -sASYNCIFY=1 flag
- Check if emscripten_sleep() is available (may need -sASYNCIFY_IMPORTS)
- Ensure linking with asyncify support
- Try recompiling with explicit asyncify flags

OPTION 2: Use Proxy Approach
- Set up a same-origin proxy on localhost:8000 that forwards to obereed.net
- This eliminates CORS issues entirely
- Nginx or simple Node.js proxy could work
- Would allow synchronous mode to work

OPTION 3: Use XMLHttpRequest Instead
- Emscripten also supports XHR via emscripten_async_wget2_data
- XHR might have better sync support than Fetch API
- Would require rewriting PostMulti to use different API

OPTION 4: Callback-Based Async Pattern
- Accept that upload must be truly async
- Store mText/mStatus in PEBLHTTP object
- Use static/global state to signal completion
- Have PEBL code poll for completion (ugly but might work)

OPTION 5: Check Emscripten Fetch Flags
- Try different attr.attributes combinations:
  - EMSCRIPTEN_FETCH_REPLACE
  - EMSCRIPTEN_FETCH_APPEND
  - Remove PERSIST_FILE flag
- Try different onsuccess/onerror callback implementations
- Add debug logging to callbacks to see if they fire

OPTION 6: Simplify to Debug
- First, get a simple GET request working with emscripten_fetch
- Then POST without body
- Then POST with small body
- Isolate where exactly it fails

IMMEDIATE NEXT ACTION
---------------------
1. Check Makefile em-opt target for Asyncify flags
2. Look at compilation output for asyncify-related warnings/errors
3. Try adding explicit flags: -sASYNCIFY=1 -sASYNCIFY_IMPORTS='["emscripten_sleep"]'
4. If Asyncify confirmed working, add more debug to see why busy-wait fails
5. Consider Option 2 (proxy) as it would be quickest workaround

FILES MODIFIED
--------------
- src/utility/PEBLHTTP.cpp (PostMulti, GetHTTPFile, GetHTTPText, PostHTTP)
- Makefile (added -DHTTP_LIB=3 to CXXFLAGS_EMSCRIPTEN line 81)
- upload-battery/test/uploadPEBL.php (added CORS headers at top)

TEST COMMAND
------------
1. Compile: make em-opt
2. Serve: python3 -m http.server 8000 (from bin/ directory)
3. Open: http://localhost:8000/pebl2.html
4. Check browser console (F12) for errors
5. Check server logs: tail -f /var/log/nginx/error.log

REFERENCES
----------
- Emscripten Fetch API: https://emscripten.org/docs/api_reference/fetch.html
- Asyncify docs: https://emscripten.org/docs/porting/asyncify.html
- PEBL upload architecture: upload_architecture_notes.txt
- CURL implementation: src/utility/PEBLHTTP.cpp lines 615-757 (PEBL_CURL section)

==============================================
UPDATE: 2025-10-14
==============================================

✅ FILE UPLOAD SUCCESSFULLY IMPLEMENTED
---------------------------------------
The HTTP file upload functionality is now working! The solution involved:

1. **Using JavaScript Fetch API directly** (src/utility/PEBLHTTP.cpp)
   - Emscripten's emscripten_fetch API had persistent issues with POST body transmission
   - Switched to calling browser's Fetch API via EM_JS() macro
   - Direct JavaScript approach bypasses emscripten_fetch limitations
   - Form data properly constructed and transmitted to server

2. **Upload validation and testing**
   - Successfully tested with PEBL server (obereed.net/PDS/)
   - Server receives $_POST parameters and $_FILES data correctly
   - Authentication via username/password works
   - File content transmitted intact (verified with CSV data)

✅ PERSISTENT FILE STORAGE WITH IDBFS
--------------------------------------
Implemented browser-based persistent storage for experiment data:

1. **IDBFS Integration** (IndexedDB Filesystem)
   - Added `-lidbfs.js` flag to Makefile em-opt target
   - Modified emscripten/shell_PEBL_debug.html to set up IDBFS before PEBL runs
   - Created /data mount point for persistent storage
   - Files written to /data persist across browser page reloads

2. **Setup Details**
   - Used `noInitialRun: true` to control execution timing
   - Mount IDBFS to /data directory in Module initialization
   - Call FS.syncfs(true, ...) to load existing files from IndexedDB
   - Call instance.callMain() after IDBFS ready
   - Auto-sync every 5 seconds via setInterval
   - Manual sync available via window.syncFS() function

3. **Files Created**
   - emscripten/load-idbfs.js: Pre-run script for IDBFS detection
   - demo/tests/test-persistence.pbl: Test script for verifying persistence
   - demo/tests/test-fileio.pbl: Basic file I/O diagnostics

4. **Key Configuration** (Makefile)
   - `-s EXPORTED_RUNTIME_METHODS='["ccall","cwrap","FS","callMain"]'`
   - `-s FORCE_FILESYSTEM=1` (ensure filesystem support)
   - `-lidbfs.js` (link IDBFS library)
   - `--pre-js emscripten/load-idbfs.js` (preload detection script)

✅ BATTERY TASK COMPILATION PROOF OF CONCEPT
---------------------------------------------
Successfully compiled and tested multiple battery tasks:

1. **Tasks Tested**
   - Corsi (upload-battery/corsi/)
   - Ptrails (upload-battery/ptrails/)
   - Both run successfully in browser
   - Data collection completes and uploads to server

2. **Configuration Pattern Established**
   - Each task needs: main.pbl, params/, translations/, upload.json
   - upload.json contains server connection details (host, port, credentials, taskname)
   - Makefile preload pattern: --preload-file task/file@virtualpath
   - Standard library and media files automatically included

3. **Upload Configuration** (upload.json structure)
   ```json
   {
     "host": "localhost",
     "page": "/uploadPEBL.php",
     "subnumpage": "/getNewSubNum.php",
     "port": 8080,
     "username": "jackaubrey",
     "uploadpassword": "commander",
     "taskname": "corsi"
   }
   ```

4. **Complete Workflow Verified**
   - Task runs in browser
   - Data saved to /data (persists via IDBFS)
   - On completion, data uploaded to server
   - Server records data for analysis

FILES ADDED/MODIFIED (2025-10-14)
----------------------------------
Modified:
- Makefile (em-opt target: IDBFS linking, preload battery tasks)
- emscripten/shell_PEBL_debug.html (IDBFS setup before main())
- src/utility/PEBLHTTP.cpp (JavaScript Fetch API implementation)

Added:
- emscripten/load-idbfs.js (IDBFS detection script)
- demo/tests/test-persistence.pbl (persistence verification test)
- demo/tests/test-fileio.pbl (basic file I/O test)
- upload-battery/corsi/upload.json (configuration)
- upload-battery/ptrails/upload.json (configuration)

CURRENT STATUS
--------------
✅ Proof of concept complete
✅ File upload working
✅ Persistent storage working
✅ Battery tasks compiling and running
✅ End-to-end workflow validated

NEXT STEPS
----------
1. Test additional battery tasks to verify broad compatibility
2. Optimize IDBFS sync timing (currently 5-second interval)
3. Add error handling for IDBFS failures
4. Consider automatic upload retry on network failures
5. Document deployment process for production use
6. Test with larger datasets/longer experiments
7. Implement progress feedback for uploads
8. Consider adding offline mode detection
