## Functions to support downloading/transferring files via http and
## other network protocols.



##This will attempt to retrieve all the files in filelist.
##
define GetFiles(filelist,filebase,urlbase)
{

  good <- 1
  success <- []
  loop(file,filelist)
   {
    if(not FileExists(filebase+file))
    {
       filesuccess <- GetHTTPFile(urlbase+file,filebase+file)
       PushOnBack(success,filesuccess)
       if(filesuccess)
       {
       Print("File:["+file+"] successfully downloaded." )
       }else{
       Print("File:["+file+"] download failed." )
        good <- 0
       }
    } else {
       PushOnBack(success,1)
       Print("File:["+file+"] previously downloaded." )
    }

   }

 return good
}


define SendFile(network,filename,id)
{
   Print("loading filename: ["+filename+"]")
   text <- FileReadText(filename)
   length <- StringLength(text)+""

   if(StringLength(length)>16)
   {
     SignalFatalError("Cannot send a file this long:"+length)
   }

   Print("Sending: [" +id +"] : "+length)
   message <-  Format(id,32)+Format(length,16) + text
   label <- EasyLabel("Attempting to send data to server (up to 10 secs)", gVideoWidth/2,gVideoHeight/2,gWin,22)
   Draw()
   Wait(500)
   success <- SendData(network,message)
   if(success)
   {
      label.text <- "Succeeded at sending data"
      Draw()
      Wait(500)
   } else {
      label.text <- "Failed to send data.  Please try again later or send data files directly. Press any key to begin."
      Draw()
      WaitForAnyKeyPress()
   }
   return success
}


## This tests whether a string is a URL (starts with http:// or https://)
define IsURL(string)
{
  if(not IsString(string))
  {
    result <- 0
  } else {
    stringLen <- StringLength(string)
    if(stringLen < 7)
    {
      result <- 0
    } else {
      ## Check for http:// or https://
      start7 <- Uppercase(SubString(string, 1, 7))
      start8 <- Uppercase(SubString(string, 1, 8))
      result <- (start7 == "HTTP://") or (start8 == "HTTPS://")
    }
  }
  return(result)
}


## This will fetch text from a URL or local file
## If source is a URL (http:// or https://), fetch via HTTP
## If source is a local file path, read with FileReadText
define FetchText(source)
{
  if(IsURL(source))
  {
    ## Parse URL to extract host, port, and path
    urlUpper <- Uppercase(source)
    if(SubString(urlUpper, 1, 8) == "HTTPS://")
    {
      rest <- SubString(source, 9, StringLength(source) - 8)
      useHTTPS <- 1
    } else {
      rest <- SubString(source, 8, StringLength(source) - 7)
      useHTTPS <- 0
    }

    ## Find first slash to separate host from path
    slashPos <- 0
    loop(i, Sequence(1, StringLength(rest), 1))
    {
      if(SubString(rest, i, 1) == "/" and slashPos == 0)
      {
        slashPos <- i
      }
    }

    if(slashPos == 0)
    {
      host <- rest
      path <- "/"
    } else {
      host <- SubString(rest, 1, slashPos - 1)
      path <- SubString(rest, slashPos, StringLength(rest) - slashPos + 1)
    }

    ## Check for port in host (host:port format)
    colonPos <- 0
    loop(i, Sequence(1, StringLength(host), 1))
    {
      if(SubString(host, i, 1) == ":")
      {
        colonPos <- i
      }
    }

    if(colonPos > 0)
    {
      portStr <- SubString(host, colonPos + 1, StringLength(host) - colonPos)
      port <- ToNumber(portStr)
      host <- SubString(host, 1, colonPos - 1)
    } else {
      if(useHTTPS)
      {
        port <- 443
      } else {
        port <- 80
      }
    }

    ## Fetch via HTTP
    result <- GetHTTPText(host, port, path)

    if(First(result) == 200)
    {
      text <- Second(result)
    } else {
      Print("WARNING: Parameter fetch failed with HTTP status " + First(result))
      Print("  URL: " + source)
      Print("  Server response: " + Second(result))
      Print("  Falling back to default parameters")
      text <- ""
    }
  } else {
    ## Local file - use FileReadText
    text <- FileReadText(source)
  }

  return(text)
}


## This will get a new subject number from an HTTP server
## Used by PEBLOnlinePlatform to assign sequential subject IDs
define GetNewSubNum(server,page,port,username,pword)
{
   file <- page + "?user_name="+username+"&upload_password="+pword
   out <- GetHTTPText(server,port,file)

   if(First(out)==200)
    {
      subraw <- Second(out)
      len <- StringLength(subraw)
      sub <- SubString(Second(out),1,len-1)
    } else {
      sub <- RandomDiscrete(999999)
    }
    return sub
}


## This uploads a data file to an HTTP server using settings from a JSON config file
## Supports token-based authentication for hosted experiments
define UploadFile(subcode,datafilename,settingsfile:"")
{
  fname <- settingsfile

  if(gUpload)
  {
    #use settingsfile if it is not blank
   if(settingsfile != "")
    {
       ##..and it exists.
     if(not FileExists(settingsfile))
     {
       settingsfile <- ""
     }
    }

    #if settingsfile is blank, then use gUploadFile:
   if(settingsfile == "")
   {
      settingsfile <- gUploadFile
      ##but only if it exists:
      if(not FileExists(settingsfile))
      {
           settingsfile <- ""
      }
   }

   ##now, settingsfile is either blank or points to an existing file. one last fallback.
   if(settingsfile=="")
   {
      if(FileExists("upload.json"))
      {
         settingsfile <- "upload.json"
      }
   }
   if(settingsfile == "")
   {
      Print("WARNING: UNABLE TO UPLOAD DATA BECAUSE SETTINGS FILE ["+fname+"] DOES NOT EXIST")
   }
  settings  <- ParseJSON(FileReadText(settingsfile))
  host <- settings.host
  page <- settings.page
  port <- ToInteger(settings.port)
  taskname <- settings.taskname
  if(taskname == "<USE_TASK_NAME>")
  {
    taskname <- gScriptName
  }

  ## Support token-based authentication
  token <- ""
  if(PropertyExists(settings, "token"))
  {
    token <- settings.token
    username <- "token_user"
    uploadpassword <- "token_auth"
  } else {
    username <- settings.username
    uploadpassword <- settings.uploadpassword
  }

  out <-   SyncDataFile(host,page,port,username,uploadpassword,taskname,subcode,datafilename,token)
 } else{
  out <- 0
 }
 return out
}


## This syncs a data file to an HTTP server via POST
## Supports token-based authentication for hosted experiments
define SyncDataFile(server,page,port,username,pword,taskname,subcode,datafilename,token:"")
{
  filecontent <-FileReadText(datafilename)

  cr <- CR(1)
  bound <- "**boundary**"
  boundary <- "--"+bound

  content <- cr+boundary  +cr+
  "Content-Disposition: form-data; name="+gQuote+"upfile"+gQuote+"; filename="+gQuote+"testpost.pbl"+gQuote +
  cr+
  "Content-Type: application/octet-stream "+cr+
  cr+
  filecontent +
  boundary + "--"
  cl <- StringLength(content)+1

  ## Build args array with standard fields
  args <- ["user_name",username,
           "upload_password",pword,
       "taskname",taskname,
       "subnum",subcode]

  ## If token is provided, add it to args for server-side validation
  if(token != "")
  {
    args <- Append(args, "auth_token")
    args <- Append(args, token)
  }

  headers <- ["Connection","close",
              "Accept", "text/plain",
              "Content-Type", "multipart/form-data; boundary="+bound,
              "Content-Length",((cl)+"")]

  out <-  PostHTTPFile(server,port,page,args,datafilename,"fileToUpload")

 return out
}
