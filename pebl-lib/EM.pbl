### These are reimplementations of functions that use the event loop thrugh compiled code.
### Using these is probably not typically slower than the compiled version, but 
### they are untested and so should only be used for emscripten implementation.


## Functions to reimplement:
## *WaitForKeyRelease
## *WaitForAnyKeyPress
## *WaitForListKeyPress

##* WAITFORANYKEYPRESSWITHTIMEOUT
##* WAITFORLISTKEYPRESSWITHTIMEOUT


## WAITFORMOUSEBUTTON
## WAITFORMOUSEBUTTONWITHTIMEOUT


##Functions that are deprecated (hopefully)
## WaitForKeyDown
## WaitForAnyKEyDown
## WaitForKeyUp
## WAITFORALLKEYSUP
## WAITFORANYKEYDOWNWITHTIMEOUT
## WAITFORKEYLISTDOWN




## for emscripten, all buult-in functions that rely on the event loop need to be re-implemneted
## in straight PEBL to restore  reentrant interactivity.
##
define Wait(time)
{


    ##register the timer
    endtime <- GetTime() + time
    RegisterEvent("<TIMER>", 1, endtime,"<GEQ>","",[])
    StartEventLoop()
    ClearEventLoop()

    
    return(1)
}


define WaitForKeyPress(key)
{

  ##register the keypress

   RegisterEvent("<KEY_PRESS>",key,0,"<EQUAL>","",[])
   out <-   StartEventLoop()
   ClearEventLoop()
   
   return(out)

}


define WaitForListKeyPressWithTimeout(keys,timeout,style:1)
{

    endtime <- GetTime() + timeout


  ##register the keypress
 loop(key,keys)
  {
     RegisterEvent("<KEY_PRESS>",key,0,"<EQUAL>","",[])
  }

   RegisterEvent("<TIMER>", 1, endtime,"<GEQ>","",[])
   out <-   StartEventLoop()
   ClearEventLoop()

   return(out)
}



define WaitForKeyPressWithTimeout(key,timeout)
{

    endtime <- GetTime() + timeout


 ##register the keypress
  RegisterEvent("<KEY_PRESS>",key,0,"<EQUAL>","",[])

   RegisterEvent("<TIMER>", 1, endtime,"<GEQ>","",[])
   out <-   StartEventLoop()
   ClearEventLoop()
   
   return(out)
}



define WaitForAnyKeyPressWithTimeout(timeout)
{

    endtime <- GetTime() + timeout


 ##register the keypress
  RegisterEvent("<KEY_PRESS>","<ANYKEY>",0,"<EQUAL>","",[])

   RegisterEvent("<TIMER>", 1, endtime,"<GEQ>","",[])
   out <-   StartEventLoop()
   ClearEventLoop()
   
   return(out)
}


define WaitForListKeyPress(keys)
{

  ##register the keypress
loop(key,keys)
  {
     RegisterEvent("<KEY_PRESS>",key,0,"<EQUAL>","",[])
  }
   out <-   StartEventLoop()
   ClearEventLoop()
   
   return(out)

}



define WaitForKeyRelease(key)
{

  ##register the keypress

   RegisterEvent("<KEY_RELEASE>",key,0,"<EQUAL>","",[])
   out <-   StartEventLoop()
   ClearEventLoop()
   
   return(out)

}

define WaitForAnyKeyPress()
{
  RegisterEvent("<KEY_PRESS>","<ANYKEY>",0,"<EQUAL>","",[])
  out <- StartEventLoop()
  ClearEventLoop()
  return(out)
} 


define WaitForAnyKeyRelease()
{

  ##register the keypress

   RegisterEvent("<KEY_RELEASE>","<ANYKEY>",0,"<EQUAL>","",[])
   out <-   StartEventLoop()
   ClearEventLoop()
   
   return(out)

}

##This should match on either down or up click.
##Returns [x, y, button, status] where status is "<pressed>" or "<released>"
##Uses polling approach because StartEventLoop doesn't block properly for mouse in Emscripten
define WaitForMouseButton()
{
    ## Poll mouse state until we see a button down, then wait for release
    waiting <- 1
    wasDown <- 0

    while(waiting)
    {
        Wait(10)  ## Small delay to avoid busy-waiting
        mouseState <- GetMouseState()

        ## mouseState is [x, y, button1, button2, button3]
        button1Down <- Third(mouseState)

        if(button1Down == 1 and wasDown == 0)
        {
            ## Button just pressed
            wasDown <- 1
            pressX <- First(mouseState)
            pressY <- Second(mouseState)
        }

        if(button1Down == 0 and wasDown == 1)
        {
            ## Button just released
            waiting <- 0
            releaseX <- First(mouseState)
            releaseY <- Second(mouseState)
        }
    }

    ## Return release position with status
    return([releaseX, releaseY, 1, "<pressed>"])
}


define WaitForMouseButtonWithTimeout(timeout)
{
    endtime <- GetTime() + timeout
    RegisterEvent("<MOUSE_BUTTON_PRESS>",1,1,"<EQUAL>","", [])


   RegisterEvent("<TIMER>", 1, endtime,"<GEQ>","",[])
   out <-   StartEventLoop()
   ClearEventLoop()

   return(out)

}


## GetInput reimplementation for emscripten
## With Asyncify, WaitForAnyKeyPress() now blocks properly
define GetInput(textbox, exitkey)
{
    SetEditable(textbox, 1)
    SetText(textbox, "")
    Draw()

    text <- ""
    continue <- 1

    while(continue)
    {
        key <- WaitForAnyKeyPress()  ## This now properly blocks via Asyncify

        if(Lowercase(key) == Lowercase(exitkey))
        {
            continue <- 0
        }elseif(key == "<backspace>")
        {
            if(StringLength(text) > 0)
            {
                text <- SubString(text, 1, StringLength(text) - 1)
                SetText(textbox, text)
                Draw()
            }
        }elseif(StringLength(key) == 1)
        {
            text <- text + key
            SetText(textbox, text)
            Draw()
        }
    }

    SetEditable(textbox, 0)
    return text
}


##############################################################################
## File operation overrides for Emscripten
## These redirect file output to console since browser has no real filesystem
##############################################################################


## Override GetNewDataFile to return a dummy file handle and print header
define GetNewDataFile(subnum, win, basename, ext, header)
{


    filename <- "data/" + subnum + "/" + basename + "-" + subnum + "." + ext

    ## Return the counter as a fake file handle
    return (FileOpenWrite(filename))
}

## Override FileOpenWrite
define FileOpenWrite(filename)
{
    Print("=== EM FILE OPENED: " + filename + " ===")
    file <- MakeCustomObject("FILEOBJECT")
    file.filename <- filename
    file.direction <- "WRITE"

    return(file)
}

## Override FileOpenAppend
define FileOpenAppend(filename)
{
    Print("=== EM FILE OPENED (APPEND): " + filename + " ===")
    file <- MakeCustomObject("FILEOBJECT")
    file.filename <- filename
    file.direction <- "APPEND"

    return(file)
}

## Override FilePrint to print to console
define FilePrint(filehandle, text)
{
    Print(text)
    return(1)
}

## Override FilePrint_ (no newline version)
define FilePrint_(filehandle, text)
{
    Print_(text)
    return(1)
}

## Override FileClose (no-op)
define FileClose(filehandle)
{

    Print("=== EM FILE CLOSED: "+ filehandle.filename)

    return(1)
}

## Override FileReadList - returns empty list since we can't read files in browser
define FileReadList(filename)
{
    Print("=== EM FILE READ (returning empty list): " + filename + " ===")
    return([])
}


