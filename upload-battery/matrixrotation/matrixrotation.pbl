#################################################################
##  PEBL Matrix Rotation Task Version 0.2
##
##  For use with PEBL 0.09 or later
##  http://pebl.sf.net
##  Part of  The PEBL Psychological Test Battery
##  2008 Released into Public Domain
##  by Shane T. Mueller, Ph.D. (smueller at obereed dot net)
##
##  This is a simple version of the 'matrix rotation' task
##  described in the UTC Test Battery test # 11
##
##  See: Perez, W. A. Masline, P. J., Ramsey, E. g., and Urban, K. E.,
##       (1987). Unified tri-services cognitive performance assessment
## 		 battery: Review and methodology.  DTIC AAMRL-TR-87-007.
##
##  See original versions by Phillips (1974) and Damos & Lyall (1984).
##
##  Phillips, W. A. (1974). On the Distinction Between Sensory Storage
##    and Short Term Visual Memory, Perception and Psychophysics, 16,
##     283-290.
##
##  Damos, D. L. and E. A. Lyall. (1984). The Effect of Asymmetric
##    Transfer on Dual Task Assessment of Voice Technology,
##	   Proceedings of the Human Factors Society 28th Annual Meeting,
##     Volume 1, 21-26.
##
##
#################################################################

 define Start(p)
{
  ## Initialize upload system (works for both online and native)
  InitializeUpload()

  parpairs <- [["size",6], #Number of rows/columns in the matrix
               ["givefeedback",1], ##whether to give feedback
	       ["condsize",10], ##number of trials of each same/different
	       ["squaresize",300], ##size of display square, in pixels.
               ["numpractice",6], ##number of practice trials (3 same, 3 diff)
               ["responsemode","keyboardShift"]]  ##Response mode for Layout & Response System

  gParams <-CreateParameters(parpairs,gParamFile)

  gSize <- gParams.size
  giveFeedback <- gParams.givefeedback
  condsize <- gParams.condsize

  gSleepEasy <- 1
  gScriptName <- "PEBL Matrix Rotation Test"
  gWin <- MakeWindow()

  ##Get subject code if we need to:
   if(gSubNum+""=="0")
    {
        gSubNum <- GetSubNum(gWin)
    }

  GetStrings(gLanguage)

  ## Create layout with response system AFTER GetSubNum
  gParams.responselabels <- [gStrings.same, gStrings.different]
  gLayout <- CreateLayout("matrixrotation", gWin, gParams)
  gLayout.header.visible <- 0
  gLayout.subheader.visible <- 0
  gLayout.footer.visible <- 0

  gLinecolor <- MakeColor("Black")
  gCellempty <- MakeColor("grey20")
  gCellFull  <-  MakeColor("orange")


  gFileOut <- GetNewDataFile(gSubNum,gWin,"matrot","csv",
        "subnum,trial,practice,samediff,dir,mat1,mat2,studytime,rt,resp,corr")

  instruc <- gStrings.instruc

  inst1 <-  gStrings.inst1

  ##Provide initial instructions
  ## Position in header/subheader region, max 1000px wide or window width - 50
  instWidth <- Min([1000, gVideoWidth-50])
  instHeight <- gLayout.stimulusRegion.y - 20  ## Height of header+subheader region
  inst <- AdaptiveTextBox(instruc, gVideoWidth/2 - instWidth/2, 10, gWin, 20, instWidth, instHeight, "scalefont")

  ## Show example stimuli in stimulus region
  ## Create a sample matrix for demonstration
  exampleMatrix <- MakeMatrix(gSize)

  ## Display two examples side-by-side: same (rotated) and different (foil)
  leftX <- gLayout.centerX - 200
  rightX <- gLayout.centerX + 200
  centerY <- gLayout.centerY

  ## Example 1: SAME (left side) - show original and rotated version
  exampleRotated <- RotateMatrix(exampleMatrix, "<right>")
  exampleLeft <- DisplayMatrixAt(exampleMatrix, leftX - 80, centerY - 50, 150)
  exampleLeftRotated <- DisplayMatrixAt(exampleRotated, leftX + 80, centerY - 50, 150)

  ## Example 2: DIFFERENT (right side) - show original and foil
  exampleFoil <- MakeFoil(exampleMatrix)
  exampleRight <- DisplayMatrixAt(exampleMatrix, rightX - 80, centerY - 50, 150)
  exampleRightFoil <- DisplayMatrixAt(exampleFoil, rightX + 80, centerY - 50, 150)

  ## Labels
  sameLabel <- EasyLabel("SAME (rotated)", leftX, centerY + 100, gWin, 18)
  diffLabel <- EasyLabel("DIFFERENT (changed)", rightX, centerY + 100, gWin, 18)

  Draw()

  WaitForLayoutResponse(gLayout, 0)

  ## Remove example stimuli
  RemoveComplex(exampleLeft, gWin)
  RemoveComplex(exampleLeftRotated, gWin)
  RemoveComplex(exampleRight, gWin)
  RemoveComplex(exampleRightFoil, gWin)
  RemoveObject(sameLabel, gWin)
  RemoveObject(diffLabel, gWin)
  Hide(inst)
  Draw()

  ## Practice trials
  if(gParams.numpractice > 0)
  {
    practiceConds <- Shuffle(Merge(Repeat("same",gParams.numpractice/2),
                                    Repeat("diff",gParams.numpractice/2)))
    trial <- 1
    loop(cond, practiceConds)
    {
      RunTrial(cond, trial, 1, inst1, giveFeedback)
      trial <- trial + 1
    }

    ## Pause before main block
    inst.text <- gStrings.practiceComplete
    Show(inst)
    Draw()
    WaitForLayoutResponse(gLayout, 0)
    Hide(inst)
  }

  ## Main trials
  conds <- Shuffle(Merge(Repeat("same",condsize),
                          Repeat("diff",condsize)))

  trial <- 1
  loop(cond,conds)
   {
     RunTrial(cond, trial, 0, inst1, giveFeedback)
     trial <- trial +1
   }

   inst.text <- gStrings.debrief
   Show(inst)
   Draw()
   WaitForLayoutResponse(gLayout, 0)

  ## Upload data files (works online, no-op on native)
  UploadFile(gSubNum, gFileOut)

}


define DisplayMatrix(mat)
{

   xcells <- Length(mat)
   ycells <- Length(First(mat))

   xcenter <- gVideoWidth/2
   ycenter <- gVideoHeight/2

   xsize <- gParams.squaresize
   ysize <- gParams.squaresize

   upper <- ycenter-ysize/2
   lower <- ycenter+ysize/2
   left <- xcenter-xsize/2
   right <- xcenter+xsize/2

   xjump <- xsize/xcells
   yjump <- ysize/ycells


  complex <- []

  #First, make the lines

  ##draw the background square
  back <- Rectangle(xcenter,ycenter,xsize,ysize,gcellempty,1)
  AddObject(back,gWin)
  complex <- Append(complex,back)

  ##Draw the 'present' cells

   row <- 1
   loop(line, mat)
     {
        col <- 1
        loop(cell,line)
         {
           if(cell==1)
           {
             x <- Rectangle(left+(col-.5)*xjump,upper+(row-.5)*yjump,xjump,yjump,gCellFull,1)
             AddObject(x,gWin)
             complex <- Append(complex,x)
           }
           col <- col +1
         }
      row <- row + 1
     }


  ##Finally, draw lines on top
  loop(i,Sequence(0,xcells,1))
  {
    l <- Line(left,upper+yjump*i,xsize,0,gLinecolor)
    AddObject(l,gWin)
    complex <- Append(complex,l)
  }

  loop(i,Sequence(0,ycells,1))
   {

    l <- Line(left+xjump*i,upper,0,ysize,gLinecolor)
    AddObject(l,gWin)
    complex <- Append(complex,l)
   }
 return complex
}

## DisplayMatrixAt - display matrix at specific location and size
define DisplayMatrixAt(mat, xcenter, ycenter, size)
{
   xcells <- Length(mat)
   ycells <- Length(First(mat))

   xsize <- size
   ysize <- size

   upper <- ycenter-ysize/2
   lower <- ycenter+ysize/2
   left <- xcenter-xsize/2
   right <- xcenter+xsize/2

   xjump <- xsize/xcells
   yjump <- ysize/ycells

  complex <- []

  ##draw the background square
  back <- Rectangle(xcenter,ycenter,xsize,ysize,gcellempty,1)
  AddObject(back,gWin)
  complex <- Append(complex,back)

  ##Draw the 'present' cells
   row <- 1
   loop(line, mat)
     {
        col <- 1
        loop(cell,line)
         {
           if(cell==1)
           {
             x <- Rectangle(left+(col-.5)*xjump,upper+(row-.5)*yjump,xjump,yjump,gCellFull,1)
             AddObject(x,gWin)
             complex <- Append(complex,x)
           }
           col <- col +1
         }
      row <- row + 1
     }

  ##Finally, draw lines on top
  loop(i,Sequence(0,xcells,1))
  {
    l <- Line(left,upper+yjump*i,xsize,0,gLinecolor)
    AddObject(l,gWin)
    complex <- Append(complex,l)
  }

  loop(i,Sequence(0,ycells,1))
   {
    l <- Line(left+xjump*i,upper,0,ysize,gLinecolor)
    AddObject(l,gWin)
    complex <- Append(complex,l)
   }
 return complex
}

define MakeMatrix(p)
{

  good <- 0
  while(not good)
   {
      tmp <- Shuffle(Sequence(1,gSize,1))
      good <- CheckMatrix(tmp)
   }

  base <- Merge([1],Repeat(0,gSize-1))
  mat <- []
  loop(i,tmp)
  {
     mat <- Append(mat, Rotate(base,i-1))
  }

  return mat
}

define RemoveComplex(comp,win)
{
  loop(i,comp)
  {
    RemoveObject(i,win)
  }
}

define RotateMatrix(mat,dir)
{
  if(dir == "<left>")
  {
   newmat <- Reverse(Transpose(mat))
  } elseif(dir == "<right>") {
   newmat <- Transpose(Reverse(mat))
  } else {
   newmat <- CopyMatrix(mat)
  }

  return newmat
}


define PrintMatrix(m)
{
  loop(i,m)
  {
    PrintList(i)
  }
}


define CopyMatrix(m)
{
   newmat <- []
   loop(i,m)
   {
    tmp <- []
     loop(j,i)
     {

      tmp <- Append(tmp,j)
     }
     newmat <- Append(newmat,tmp)
   }
   return newmat
}

define MakeFoil(m)
{

  size <- Length(m)
  bad <- 1
  while(bad)
  {
 #Take one of the rows and move it to a new spot.
  standard <- Sequence(1,size,1)
  rows <- ChooseN(Sequence(1,size,1),2)
  neword <- Replace(standard, [rows,Reverse(rows)])

  try <- SortBy(m,neword)
   if(CheckMatrix(try))
     {
       bad <- 0
     }
  }

  return try
}

define MatrixEqual(m1,m2)
{

  equal <- 1
  test <- Transpose([m1,m2])
  loop(i,test)
  {
    ii <- Transpose(i)
    loop(j, ii)
    {
      if(not (First(j) ==Nth(j,2)))
       {
            equal <- 0
       }
    }

  }

  return equal
}


define CheckMatrix(list)
{

  seq <- Sequence(1,Length(list),1)

  ok <-1
  if(list == seq or
     list == Reverse(seq))
   {
    ok <- 0
   }

 return ok
}





## RunTrial - Execute a single trial of the matrix rotation task
define RunTrial(cond, trialNum, isPractice, inst1, giveFeedback)
{
   ##Create test matrix
   matrix <- MakeMatrix(gSize)

   ##Choose the rotation direction for test matrix.
   dir <- Sample(["<right>","<left>"])

   starttime <- GetTime()
   FilePrint_(gFileOut,gSubNum + "," + trialNum + "," + isPractice + "," + cond + "," + dir + "," )

   if(cond =="same")
    {
      alt <- matrix
    } else {
      alt <- MakeFoil(matrix)
    }
    #Create the test matrix
    test <- RotateMatrix(alt,dir)

    FilePrint_(gFileOut,ConcatenateList(Flatten(matrix),",") + ",")
    FilePrint_(gFileOut,ConcatenateList(Flatten(test),",")   + ",")

 ##Present the study matrix
    gLayout.footer.visible <- 1
    gLayout.footer.text <- inst1

    ## For mouse/touch modes, hide response targets during study matrix
    isMouseMode <- IsMember(gParams.responsemode, ["mouseTarget", "touchTarget", "mouseButton"])
    if(isMouseMode)
    {
      loop(label, gLayout.responseLabels)
      {
        Hide(label)
      }
      loop(border, gLayout.responseBorders)
      {
        Hide(border)
      }
    }

    x <- DisplayMatrix(matrix)
    Draw()

    ## For mouse/touch modes, wait for any click; otherwise wait for proper response
    if(isMouseMode)
    {
      WaitForMouseButton()
    } else {
      WaitForLayoutResponse(gLayout, 0)
    }

    t1 <- GetTime()
    RemoveComplex(x,gWin)

    ## For mouse/touch modes, show response targets again for test matrix
    if(isMouseMode)
    {
      loop(label, gLayout.responseLabels)
      {
        Show(label)
      }
      loop(border, gLayout.responseBorders)
      {
        Show(border)
      }
    }

 ## Present the test matrix
    gLayout.footer.text <- ""
    x <- DisplayMatrix(test)
    Draw()
    resp <- WaitForLayoutResponse(gLayout, 0)
    RemoveComplex(x,gWin)
    t2 <- GetTime()

    corr <- (resp == Lookup(cond,["same","diff"],["left","right"]))
    FilePrint(gFileOut,(t1-starttime) + "," + (t2-t1) + "," + resp + "," + corr)

    if(giveFeedback)
    {
        feedbackText <- gStrings.incorrect
        if(corr)
        {
         feedbackText <- gStrings.correct
        }
        feedbackLabel <- EasyLabel(feedbackText, gVideoWidth/2, gVideoHeight/2, gWin, 64)
        Draw()
        Wait(800)
        RemoveObject(feedbackLabel, gWin)
    }
}


define GetStrings(lang)
{
  gStrings <- GetTranslations("matrixrotation",lang)

}
