
##  PEBL Clock Task
##  An implementation of the so-called "Mackworth Clock" test.
##  (C) 2011 Shane T. Mueller
##  smueller@obereed.net
##
##  To cite:  Mueller, S. T. (2011). PEBL's Clock Test.  Computer
##  software retrieved from http://pebl.sf.net/battery.html
##
##
##
##  http://en.wikipedia.org/wiki/Mackworth_Clock
### Mackworth, N. H. (1948). The breakdown of vigilance during
##  prolonged visual search. Quarterly Journal of Experimental
##  Psychology, vol. 1, pp.6-21
##
##
##  Shackel, B. (1999). How I broke the Mackworth clock test (and what
##  I learned). In Hanson, M., Lovesey, E. J., and Robertson,
##  S. A. Contemporary Ergonomics 1999. Taylor & Francis. (pp. 193-197)
##
##  Lichstein, K. L., Riedel, B. W., & Richman, S. L. (2000). The
##    Mackworth clock test: A computerized version (statistical data
##    included). The Journal of Psychology.
##    http://www.encyclopedia.com/doc/1G1-62024427.html

define Start(p)
{
     ## Initialize upload system (works for both online and native)
     InitializeUpload()

     ##Set initial values to use if .par file does not exist.
     parpairs <- [["pskip",0.4],
                  ["radius",240], ##radius in pixels of clock
                  ["size",9],  ##size of target
    	          ["trials",300], ##number of 1-sec trials: default to 5 minutes
                  ["responsemode","spacebar"]]  ##Response mode (spacebar, leftclick, touchscreen)


  gParams <- CreateParameters(parpairs,gParamFile)

  gWin <- MakeWindow("black")
  gBasecolor <- MakeColor("white")
  gTargcol <- MakeColor("red")

   ##Get subject code if we need to:
   if(gSubNum+""=="0")
    {
	  gSubNum <- GetSubNum(gWin)
    }

   GetStrings(gLanguage)

  ## Create layout with custom zones to maximize clock space
  ## Design for 800x600: stimulus=500px, footer=50px, response=50px
  gLayout <- CreateLayout("clocktest", gWin, gParams)

  ## CUSTOM ZONES: Maximize stimulus region for clock (500px on 800x600, scaled proportionally)
  gLayout.header.visible <- 0
  gLayout.header.height <- 0
  gLayout.subheader.visible <- 0
  gLayout.subheader.height <- 0

  ## Scale zone heights proportionally to screen size (base: 600px height)
  scaleFactor <- gVideoHeight / 600.0
  footerHeight <- Round(50 * scaleFactor)
  responseHeight <- Round(50 * scaleFactor)
  stimulusHeight <- gVideoHeight - footerHeight - responseHeight

  ## Update zone metadata (not the label itself)
  gLayout.zones.footer.height <- footerHeight
  gLayout.zones.footer.y <- stimulusHeight
  gLayout.footer.visible <- 1

  ## Recalculate stimulus region with new zone heights
  gLayout.stimulusRegion.y <- 0
  gLayout.stimulusRegion.height <- stimulusHeight
  gLayout.centerX <- gVideoWidth / 2  ## Use full screen width for centering
  gLayout.centerY <- gLayout.stimulusRegion.height / 2

  ## Position clock center
  gHomeX <- gLayout.centerX
  gHomeY <- gLayout.centerY

  ## Reposition footer to use correct centerX and new zone position
  Move(gLayout.footer, gLayout.centerX, gLayout.zones.footer.y + (gLayout.zones.footer.height / 2))


  ## Reposition response labels to be centered (they were also created with old positions)
  if(Length(gLayout.responseLabels) > 0)
  {
    numLabels <- Length(gLayout.responseLabels)
    spacing <- gVideoWidth / (numLabels + 1)
    responseCenterY <- gLayout.zones.response.y + (responseHeight / 2)

    loop(i, numLabels)
    {
      label <- Nth(gLayout.responseLabels, i)
      Move(label, spacing * i, responseCenterY)


      ## Also reposition border if it exists
      if(Length(gLayout.responseBorders) > 0)
      {
        border <- Nth(gLayout.responseBorders, i)
        Move(border, spacing * i, responseCenterY)
      }
    }
  }

  ## Adaptive clock radius: max 240px, scale down proportionally if screen < 600px high
  if(gVideoHeight < 600)
  {
    ## Scale radius proportionally for small screens
    radiusScale <- gVideoHeight / 600.0
    gParams.radius <- Round(gParams.radius * radiusScale)
  }
  ## Also ensure radius fits within available space (with 10% margin)
  maxRadius <- Round(Min([gLayout.stimulusRegion.width, gLayout.stimulusRegion.height]) * 0.45)
  gParams.radius <- Min([gParams.radius, maxRadius])

  ## Hide cursor for all response modes
  ShowCursor(0)

  ## Store reference to response label for feedback
  if(Length(gLayout.responseLabels) > 0)
  {
    gResponseLabel <- First(gLayout.responseLabels)
  }

  #Get starting position and put red target there.
  xy <- GetXY(1)
  targ <- Circle(First(xy),Second(xy),gParams.Size,gTargcol,1)
  AddObject(targ,gWin)




  ##Create target positions:
  pos <- []
  circs <- []
  mins <- Sequence(1,60,1)
  loop(i,mins)
  {
     xy <- GetXY(i)
     pos <- Append(pos,xy)
     circ <-  Circle(First(xy), Second(xy),gParams.Size,gBaseColor,0)
     AddObject(circ,gWin)
	 circs <- Append(circs,circ)


  }
  fileOut <- GetNewDataFile(gSubNum,gWin,"clock","csv",
               "subnum,trial,ticker,sec,skip,resp,corr,starttime,rt,curtime")



  ## Show instructions at top of screen (small textbox ~100px high so clock is visible)
  instBox <- AdaptiveTextBox(gStrings.inst1+"   " + gStrings.inst2, 50, 20, gWin, 18, gVideoWidth-100, 100, "scalefont")
  Draw()
  WaitForLayoutResponse(gLayout)
  RemoveObject(instBox, gWin)
  Draw()


  trial <- 1
  ticker <- 1
  second <- 1
  doskip <- 0
  lastend <- GetTime()
  skips <- 0
   dataRT <- []
   dataCorr <- 0
   dataTargets <- 0
    fa <- 0
    hit <- 0
    corrs <- 0

  while(trial <= gParams.trials)
  {
   ##compute seconds/clock position, and move there.
    second <- Mod(ticker,60)
    pos <- GetXY(second)
    Move(targ,First(pos),Second(pos))
    Show(targ)
    Draw()

    ##cycle should end 1000 ms after current
    nexttime <- lastend + 1000
    curtime <- GetTime()

    ## Use Layout & Response System - works with all response modes
    resp <- WaitForLayoutResponse(gLayout, nexttime - curtime)
    rtime <- GetTime()

    ## Score response
    if(resp == "<timeout>")
     {
       pressed <- 0
       resp <- 0
     } else {
       ## Response was made (any mode) - give visual feedback
       pressed <- 1
       resp <- 1

       ## Visual feedback: briefly make label bold
       if(VariableExists("gResponseLabel"))
       {
         gResponseLabel.font.bold <- 1
         Draw()
         Wait(150)
         gResponseLabel.font.bold <- 0
         Draw()
       }

       Wait(nexttime - GetTime())
     }

    corr <- resp == doskip
    corrs <- corrs + corr
    hit <- hit + (doskip and corr)
    fa <- fa + ((not doskip) and (not corr))

    if(resp== 1 and corr)
    {
      PushOnEnd( dataRT, (rtime-curtime))
    }

     dataCorr <- dataCorr+ corr

    FilePrint(fileout,gSubNum + "," + trial + "," + ticker + "," + second + "," + doskip+
	       "," + resp +"," + corr + "," + rtime + "," + (rtime - curtime) + "," + GetTime())
    lastend <- GetTime()
    skips <- skips + doskip

    ##Determine if we should skip on this trial.
    if(Random() < gParams.pskip)
     {
       doskip <- 1

     } else {

       doskip <- 0
     }

    trial <- trial + 1
    ticker <- ticker + doskip + 1
    dataTargets <- dataTargets + doskip

    ##Do a brief disappear of the target.

    Hide(targ)
    Draw()
    Wait(400)
  }

  text <- "PEBL Mackworth Clock Test "+ CR(1)+
          TimeStamp()+CR(1)+

 	  "Trials:     "+ gParams.trials+ CR(1)+
	  "Targets (skips):   " + skips +CR(1)+
          "Correct Responses: "+ corrs+CR(1)+
          "Correct targets:   " +hit+ CR(1)+
	  "False alarms:      " +fa+CR(1)+
	  "Mean correct RT:   "  +Mean(dataRT)+CR(1)

  ## Show debrief using AdaptiveTextBox
  debriefBox <- AdaptiveTextBox(text + gStrings.debrief, 100, 100, gWin, 24, gVideoWidth-200, gVideoHeight-200, "scalefont")

   report <- FileOpenAppend("data/"+ gSubNum+"/clock-report-"+gSubNum+".txt")
   FilePrint(report,text)
   FileClose(report)

   ## Upload data files (works online, no-op on native)
   UploadFile(gSubNum, "data/" + gSubNum + "/clock-" + gSubNum + ".csv")
   UploadFile(gSubNum, "data/" + gSubNum + "/clock-report-" + gSubNum + ".txt")

   Draw()
   WaitForLayoutResponse(gLayout)


}

##Gets x,y coordinates based on 1:60 minutes.
define GetXY(minute)
{
     angle <- 2*3.14159/360 * (minute * 6 -90)
     x <- gParams.radius * Cos(angle) + gHomeX
     y <- gParams.radius * Sin(angle) + gHomeY
  return [x,y]
}


define GetStrings(lang)
{
   ##Known trasnlations: EN
   gStrings <- GetTranslations("clocktest", lang)
   
   minutes <- gParams.trials / 60
   gStrings.inst1 <- SubstituteStrings(gStrings.inst1,[["<MINS>",minutes]])
   
}
