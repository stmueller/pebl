##   Spatial grid (drawing) task.
##   This incorporates a fixed 2.5 min (150 sec) deadline
##   which is around the median time for problems 1 and 2
##   and greater than median for problems 3-4
 

define Start(p)
{

  gWin <- MakeWindow()
  if(gSubnum +"" =="0")
  {
    gSubNum <-  GetSubNum(gWin)
   }
  gPage <- 1



  ##set default parameter values, in case .par file does not exist
  parpairs <- [["doTrails",0],  
               ["doCube",1],
	       ["doClock",0],
	       ["doShape",0],	       
	       ["doStemCompletion",0],
	       ["useRandom",0],
	       ["savescreenshots",0],
	       ["doAudioHelp",0],
	       ["useTimer",1]]
	       
  gParams <- CreateParameters(parpairs,gParamFile)

 totalScore <- []
 startTime <- GetTime()
 
 MakeDirectory("data")
 gfileOut <- GetNewDataFile(gSubNum,gWin,"spatialdrawing","csv",
                  "subid,abstime,trial,edits,deletes,edges,drawtime,standard,drawndiagram")

 #gfileHTMLReport <- GetNewDataFile(gSubNum,gWin,"spatialdrawing","html", "")


##pool data here.


if(gParams.doCube)
{
  cubeDat <- DrawCubeTest()
  MessageBox("This phase of the test is complete. Click OK to continue.",gWin)
}





##end it all
 totalTime <- GetTime() - starttime
 scores <- Transpose(totalScore)
 header <- ["Task","Points","Max","Time completed"]

  outcsv <-""
loop(i,totalscore)
{
 line <- Merge([gSubnum],i)
 outcsv <- outcsv + ConcatenateList(line,",")+CR(1)
}

FilePrint(gFileOut,outcsv)
#FilePrint( gFileHTMLReport,PageEnd([header,totalscore],
#                          Sum(Second(scores)),Sum(Third(scores)),
#                          totalTime))

   
#   FileClose(fileHTMLReport)
#   Launchfile(fileHTMLReport.filename)
}



define PlotTargets(pts,size,labels)
{



  comp <- []
  highlighted <- Repeat(1,Length(pts))
  tmp <- Transpose([pts,labels,highlighted])
  loop(i,tmp)
   {
      pos <- First(i)
      label <- Nth(i,2)
      highlight <- Nth(i,3)
      comp <- Append(comp,  AddTarget(pos,label,size,highlight))
   
   }
 return comp
}



define AddObjects(oblist,win)
{
 loop(i,oblist)
 {
    AddObject(i,win)
 }
}



define AddTarget(pos,letter,size,clicked)
{

    ##if type== 1, add an accented circle around the target.

   x <- First(pos)
   y <- Nth(pos,2)

   if(clicked)
    {
       crc1 <- Circle(x,y,size+5,gAccentColor,1)
       crc2 <- Circle(x,y,size,gStimColor,1)
       crc1.aa <- 1
       crc2.aa <- 1

    } else {

       crc1 <- Circle(x,y,size,gStimColor,1)  ##accent in the same color
       crc2 <- Circle(x,y,size,gStimColor,1)  ## the circle when selected
       crc1.aa <- 1
       crc2.aa <- 1

    }


    AddObject(crc1,gWin)
    AddObject(crc2,gWin)
    lab <- MakeLabel(letter+"",gstimFont)
    AddObject(lab,gWin)
    Move(lab,x,y)

   obj <- MakeCustomObject("target")
   obj.x <- x
   obj.y <- y
   obj.radius <- size
   obj.value <- letter
   obj.circle1 <- crc1
   obj.circle2 <- crc2
   obj.label <- lab
   obj.clicked <- clicked
   obj.inside <- "INSIDECIRCLE"
   obj.addobject <- "ADDCIRCLE"
   return obj
}


define AddCircle(obj,win)
{
   AddObject(obj.circle1,win)
   AddObject(obj.circle2,win)
   AddObject(obj.label,win)
}

define InsideCircle(xy,obj)
{
    inside <- 0
   if( Sqrt( (obj.x-First(xy))^2 + (obj.y - Second(xy))^2) <= obj.radius)
   {
     inside <- 1
   }

  return inside
}


define DrawPath(path,pts)
{


      ##Path is a sequence of targets
      ##pts is a list of [x,y] points

      pts2 <- SortBy(pts,Order(path))
      last <- Last(pts2)
      stimObjects <- []


      loop(i,pts2)
       {

        x0 <- First(last)
        y0 <- Nth(last,2)

        xdiff <- First(i) - x0
        ydiff <- Nth(i,2) - y0
        l <- Line(First(last),Nth(last,2),xdiff,ydiff,gStimColor)
#        l <- ThickLine(First(last),Second(last),x0,y0,4,gStimColor)
        AddObject(l,gWin)
        stimObjects <- Append(stimObjects,l)
        last <- i
       }

  return stimObjects
}

define HTMLTrailsOutput(dat)
{

  out <- HL()+H("PCST Trails Test",2) +Hl()+
        P(Timestamp())+
        P( B("Points earned (out of 1): ")+ First(dat))+
	P( B("Correct clicks:           ")+ Second(dat))+
	P( B("Error clicks:             ")+ Third(dat)) +
	P( B("Time taken:               ") +Round(Fourth(dat)/1000,2) + " sec")

   if(gParams.savescreenshots)
       {
         out <- out + Img("trails.png",600)
       }
  return MakeDivPage(out )
}


##############################################################
##############################################################
## Copy-cube subtest.

## The goal is to copy a 'necker' cube, but permit it to be done simply
## with a mouse.


define DrawCubeTest ()
{
   gstrings <- GetTranslations("spatialgrid", gLanguage)

   DoInstructions(gstrings.taskname,
                  gstrings.longinst,
		  "translations/"+gstrings.longinstimage,
		  "translations/"+gstrings.longinstsound)



##Set up timer globals
buttonColor <- MakeColor("gold")
   deleteButton <- Rectangle(850,900,200,50,buttonColor,1)
  timerBack <-  Rectangle(550,900,300,20,MakeColor("grey"),0)
  timerFront <-  Rectangle(550,900,300,20, MakeColor("red"),1)
  timerText <- EasyLabel("",550,950,gWin,24,buttonColor)

  AddObject(timerFront,gWin)
  AddObject(timerBack,gWin)

 gTimer <- MakeCustomObject("timer")
 gTimer.front <- timerFront
 gTimer.back <- timerBack
 gTimer.text <- timerText







  ## classic cube:
#   diagram1 <- [[3,10],[10,80],[80,73],[73,3],
#               [21,28],[28,98],[98,91],[91,21],
#	       [3,21],[10,28],[80,98],[73,91]]
diagram1 <- [[101, 6], [6, 16], [16, 216], [216, 206], [206, 6], [206, 261], [261, 101], [261, 271], [271, 216], [16, 111], [111, 271], [111, 101]]



  diagram2 <-  [[124, 87], [87, 90], [90, 133], [133, 273], [124, 264], [264, 273],
[267, 127], [127, 130], [130, 270], [273, 313], [313, 304], [304, 264], [304, 366], [313, 371],
[371, 370], [370, 331], [331, 326], [326, 367], [367, 366]]


##widget 2:
#diagram3 <- [[65, 67], [67, 87], [87, 93], [93, 73], [73, 75], [75, 135], [135, 125],
#          [125, 65], [88, 128], [92, 132], [133, 313], [127, 307], [313, 352],
#          [352, 348], [348, 307], [348, 390], [352, 390], [226, 234], [247, 253], [207, 213]]

 
## widget 4:
diagram4 <- [[66, 76], [76, 336], [336, 326], [326, 66], [70, 190], [228, 76], [226, 236], [256, 332], [146, 156]]

diagram5 <- [[124, 64], [64, 67], [67, 150], [150, 153], [153, 74], [74, 76], [76, 136], [124, 188], [188, 308], [136, 215], [215, 335], [335, 333], [333, 233], [233, 211], [211, 310], [308, 310]]

  trial <- 1
  out <- CubeTrial(diagram1)
  FilePrint(gFileOut,gSubNum+","+ GetTime() + "," + trial +","+ ListToString(out,","))
  Print(out)
  trial <- 2

  out <- CubeTrial(diagram2)
  FilePrint(gFileOut,gSubNum+","+ GetTime() + "," + trial +","+ ListToString(out,","))
    Print(out)
#  trial <- 3
#  out <- CubeTrial(diagram3)
#  FilePrint(gFileOut,gSubNum+","+ GetTime() + "," + trial +","+ ListToString(out,","))
  Print(out)
  trial <- 3 
  out <- CubeTrial(diagram4)
  FilePrint(gFileOut,gSubNum+","+ GetTime() + "," + trial +","+ ListToString(out,","))
  Print(out)
  trial <- 4
  out <- CubeTrial(diagram5)
    Print(out)
  FilePrint(gFileOut,gSubNum+","+ GetTime() + "," + trial +","+ ListToString(out,","))

}

define CubeTrial(diagram,style:"orthographic")
{



  inst1 <- MakeHeader(gstrings.inst1,gVideoWidth/2,100,gWin,28)
  inst2 <- MakeHeader(gstrings.inst2,gVideoWidth/2,150,gWin,22)
  buttonColor <- MakeColor("gold")

  
  standard <- MakeGrid(gWin,20,20,100,700,200,800,4,"grey30","isometric")
  theGrid <-  MakeGrid(gWin,20,20,800,1400,200,800,9,"grey30","isometric")


 
  box1 <- Rectangle(400,500,650,650,MakeColor("grey30"),0)
  box2 <- Rectangle(1100,500,650,650,MakeColor("grey30"),0)
  AddObject(box1,gWin)
  AddObject(box2,gWin)
  
   deleteButton <- Rectangle(850,900,200,50,buttonColor,1)
   AddObject(deleteButton,gWin)
   deleteLabel <- Easylabel(gstrings.delete,deleteButton.x,deleteButton.y,gWin,25,"grey20")


   okButton <- Rectangle(1150,900,200,50,buttonColor,1)
   AddObject(okButton,gWin)
   okLabel <- Easylabel(gstrings.ok,okButton.x,okButton.y,gWin,25,"grey20")


  points  <- theGrid.points
  indexes <- theGrid.indexes


  ids <- Sequence(1,Length(points),1)
  startTime <- GetTime()
  Draw()


   newDiagram <- []


   standardSketch <-   DrawSketch(diagram,standard,MakeColor("red"))
   out <- DrawSketch(newDiagram,theGrid,MakeColor("grey60")) ##draw initial grid
   ##out is a list of drawn lines.

   maxtime <- 15000000
#   maxtime <- 10000


   
   Draw()
   cont <- 1

   ## some general stats.

   edits <- 0
   deletes <- 0  
   startTime <- GetTime()

   #At the beginning of the problem, do an OK and set the timeout time.
   timeout <- GetTime()+maxtime
   UpdateTimer(timeout,maxtime,gTimer)
   OKBox(gVideoWidth/2,gVideoHeight/2,"Ready to begin problem?")
   timeout <- GetTime()+maxtime
   
   while(cont)
   {

   UpdateTimer(timeout,maxtime,gTimer)
   RegisterEvent("<TIMER>", 1, GetTime()+500,"<GEQ>","UpdateTimer", [timeout,maxtime,gTimer])
   RegisterEvent("<TIMER>", 1, timeout,"<GEQ>","EndTrial", [timeout])
   
   
   #these are the clickons for just the grid--to be used for end-point of a line drawing
   baseclickons <- Merge(thegrid.points,[okButton,deleteButton])
   baseIdent <-   Merge(ids,["OK","DEL"])
   baseIndexes <- Sequence(1,Length(baseIdent),1)

   ### Make a separate list of clickons for lines as well.
   clickons <- Merge(Merge(thegrid.points,out),[okButton,deleteButton])

   lineIDs <- []
   if(Length(out)>0)
   {
     lineIDs <-  Sequence(10001,10000+Length(out),1)
   }


   ident <- Merge(Merge(ids,lineIDs),["OK","DEL"])
   indexes <- Sequence(1,Length(ident),1)


      ##get start of line

      index <- WaitForClickOnTarget(Reverse(clickOns),Reverse(indexes))

      
      start <- Nth(ident,index)
      edits <- edits + 1
     if(start == "DEL")
     {
       if(Length(newDiagram) <= 1)
       {
           newDiagram <- []
       } else{
       
          newDiagram <- SubList(newDiagram,1,Max([1,Length(newDiagram)-1]))
       }

       out <- DrawSketch(newDiagram,theGrid,MakeColor("grey60"))
       clickons <- []
       deletes <- deletes + 1
       edits <- edits + 1
       Print("drawing post-delete")
       Draw()


     }elseif( start == "OK")
     {

      confirm <- ConfirmDelete(okbutton.x,okbutton.y,"Confirm diagram complete.")


       if(Length(newDiagram)==0 or confirm == "no")
       {
         cont <- 1 ##maybe a popup messagebox here.
       } else {
         cont <- 0   ##exit.
       }
       
     } elseif(IsNumber(start) and start <=Length(points)) {
       edits <- edits + 1
       ##start is the index number. highlight the circle and collect the endpoint.

      targ <- Nth(thegrid.points,start)
      circ1 <- Circle(targ.x,targ.y,14,MakeColor("yellow"),1)
      AddObject(circ1,gWin)
      Draw()
      #only end at end circles.

      UpdateTimer(timeout,maxtime,gTimer)
      RegisterEvent("<TIMER>", 1, GetTime()+500,"<GEQ>","UpdateTimer", [timeout,maxtime,gTimer])
      RegisterEvent("<TIMER>", 1, timeout,"<GEQ>","EndTrial", [timeout])

      end <- WaitForClickOnTarget(baseclickOns,baseident)
     if(end == "DEL")
     {
      #no-op
     }elseif( end == "OK")
     {
       #cont <- 0
       
     } else {
       ##this is the endpoint
       if(IsLegalSegment(start,end,"isometric"))
       {

       ##end is the index number of a point.

      targ2 <- Nth(thegrid.points,end)
      circ2 <- Circle(targ2.x,targ2.y,12,MakeColor("yellow"),1)
      AddObject(circ2,gWin)
      Draw()
      Wait(50)
      RemoveObject(circ1,gWin)
      RemoveObject(circ2,gWin)
      Draw()
      if(start <> end)
      {
        PushOnEnd(newDiagram,[start,end])
      }
      out <- DrawSketch(newDiagram,theGrid,MakeColor("grey60"))
     }
     }
   } elseif(IsNumber(start) and start>10000) {
    edits <- edits + 1

    

     ##clicked on a line.
     line <- Nth(clickons,index)
     SetConnectorColor(line,buttonColor)

     # diagram if necessary.
     deleteline <- ConfirmDelete(First(gClick),Second(gClick))
     Print(deleteline)
     if(deleteline=="no")
     {
       SetConnectorColor(line,MakeColor("grey50"))



     } else {  ##delete
       deletes <- deletes + 1
       sketchindex <- start-10000
       newDiagram <- RemoveSubset(newDiagram,[sketchindex])
       out <- DrawSketch(newDiagram,theGrid,MakeColor("grey60"))

     }
     line <- 0 #reset line variable so it can be deleted off of the
     clickons <- [] #reset clickons because we may have deleted something, and
                    #we don't want them standing around still.
   }
   ClearEventLoop()
   Draw()

     ##end if time is up.
    if(GetTime()>timeout)
    {
     cont <- 0
     clickons <- []
     out <- []
    }
  }
  time <- GetTime()

   inst1.text <- gstrings.complete
#   inst2.text <- gstrings.continue
   Draw()
   Wait(100)


  ##recode the diagram and the solution here.
  diagramtext <-   StringifyDiagram(diagram)
  solutiontext <-  StringifyDiagram(newdiagram)

  Print(newdiagram)
  score <- [edits,deletes,Length(newDiagram),time-starttime,diagramtext,solutiontext]
  
  return score
}

define StringifyDiagram(diagram)
{
  out <- []
  loop(i,diagram)
  {
    PushOnEnd(out,ListToString(i,";"))
  }
  
  return  ListToString(out,"|")
}


##Add 
define DrawSketch(sketch,bg,color)
{
  lines <- []
  
  loop(i,sketch)
  {   
  

      startPoint <- Nth(bg.points,First(i))
      startX <- startPoint.x
      startY <- startPoint.y
      
# This calculated the position, but we will take it from the points circle
## to permit orthographic drawings.
      startindex <- Nth(bg.indexes,First(i))      
#      startx <- bg.xmin + bg.xDelta * (First(startIndex)-1)
#      starty <- bg.ymin + bg.yDelta * (Second(startIndex)-1)


      endPoint <- Nth(bg.points,Second(i))
      endX <- endPoint.x
      endY <- endPoint.y
      
      endindex <- Nth(bg.indexes,Second(i))
 #     endx <- bg.xmin + bg.xDelta * (First(endIndex)-1)
 #     endy <- bg.ymin + bg.yDelta * (Second(endIndex)-1)
      
#     Print(startindex + " to " + endindex + ": " + startx+","+starty + "-->"+  endx + "," + endy)
   
    line <-  MakeConnector(startx,starty,endx,endy,5,color)
    AddObject(line,bg.win)
    PushOnEnd(lines,line)
  }

  return lines
}



define MakeGrid(win,width,height,xmin,xmax,ymin,ymax,circsize:10,color:"grey",style:"orthographic")
{


  yminTmp <- ymin

  col <- MakeColor(color)
  xDelta <- (xmax - xmin)/ (width-1)
  yDelta <- (ymax - ymin)/ (height-1)

  odd <- 1
  points <- []
  coords <- []
  Print("starting layouot")
  loop(j,height)
  {
  
    loop(i,width)
    {


    ##reset minimum x value for each column under isometric.
   if(style=="isometric")
   {


    if(odd)
     {

        ymin <- yminTmp + yDelta/4
     } else {

        ymin <- yminTmp - yDelta/4
      }

   
    odd <- 1-odd
    }    

       point <- Circle(xmin  + xDelta * (i-1),ymin + yDelta * (j-1), circsize,col,0)
       AddObject(point,win)
       PushOnEnd(points,point)
       PushOnEnd(coords,[i,j])
		       
    }
  }


  theGrid <- MakeCustomObject("grid")
  theGrid.points <- points
  theGrid.indexes <- coords
  theGrid.xmin <- xmin
  theGrid.xmax <- xmax
  theGrid.ymin <- ymin
  theGrid.ymax <- ymax
  theGrid.xdelta <- xDelta
  theGrid.ydelta <- yDelta
  theGrid.width <- width
  theGrid.height <- height
  theGrid.win <- win
  return (theGrid)
}

define IsLegalSegment(point1,point2,style:"orthographic")
{
  Print("cheicking legal")
  Print(point1+"--->"+point2)
  
  if(point1 == point2)
  {
     ##disallow same-node clicks
     legal <- 0
  } else  {
    legal <- 1
  }
   
  return legal
}
define ScoreCube(standard,answer)
{

  ##first, sort each of these.

  stand2 <- []
  loop(i,standard)
  {
    sorted <- Sort(i)
    PushonEnd(stand2,First(sorted) + "-" + Second(sorted))
  }


  ans2 <- []
  loop(i,answer)
  {
    sorted <- Sort(i)
    PushonEnd(ans2,First(sorted) + "-" + Second(sorted))
  }


 ## now, identify matches and mismatches.


 matches <- []
 nonmatches <- []
 loop(i,stand2)
 {
   if(IsMember(i,ans2))
   {
     PushOnEnd(matches,i)
   } else {
    PushOnEnd(nonmatches,i)
   }

  ##filter that matches what we just found.
  removematches <- Match(Match(ans2,i),0)  ##reverses matches
  
  ans2 <- Filter(ans2,removematches)
  
 }

  matchscore <-  Length(matches)
  nonmatchscore <- Length(nonmatches)
  missing <- Length(ans2)


  score <-  0+ ((matchscore - nonmatchscore - missing )==Length(standard))
  return ( [score,matchscore,nonmatchscore,missing])
}

define Even(p)
{
  return Floor(p/2)*2==p
}
define Odd(p)
{
   return 1- (Mod(p,2)==0)
}


define HTMLCubeOutput(dat)
{

  out <- HL()+H("PCST Cube-drawing Test",2) +Hl()+
        P(Timestamp())+
        P( B("Points earned (out of 1): ") + First(dat))+
	P( B("Matched lines:            ") + Second(dat))+
	P( B("Missing lines :           ") + Third(dat)) +
        P( B("Extra lines :             ") + Fourth(dat)) +
	P( B("Time taken:               ") +Round(Fifth(dat)/1000,2) + " sec")
	
   if(gParams.savescreenshots)
       {
         out <- out + Img("cube.png",300)
       }

  return MakeDivPage(out)
}




define Tabulize (list)
{
  tmp <- ""
   loop(i,list)
   {
     tmp <- tmp + i+ "    "
   }
   return tmp
}





define DoInstructions(title,text,image,soundfile)
{
  ##The text should be in a panel on the top.
  ## the image should be no bigger than 800 x 600, and will be centered on the bottom.
  ## the sound file will be optional, but will play automatically.


  headerFont <-  MakeFont(gPEBLBaseFontMono,0,30,MakeColor("gold"),MakeColor("black"),0)
  textFont   <- MakeFont(gPEBLBaseFontMono,0,22,MakeColor("grey90"),MakeColor("black"),0)

  lab <- MakeLabel(title,headerFont)
  Addobject(lab,gWin)
  Move(lab,gVideoWidth/2,50)
  text <- MakeTextBox(text,textFont,800,300)
  AddObject(text,gWin)
  Move(text,(gVideoWidth-800)/2,100)

 if(FileExists(image))
  {
    imageMaxHeight <-( gVideoHeight-(text.y+text.height))-100
    img <- MakeImage(image)

  scale <-imageMaxHeight / img.height
  if(scale<.9)
   {
    img.zoomX <- scale
    img.zoomY <- scale
    }
  AddObject(img,gWin)
  Move(img,gVideoWidth/2, 400 + img.height/2)
  }
  Draw()
  
  if(FileExists(soundfile) and gParams.doAudioHelp)
  {

    sound <- LoadSound(soundfile)
    PlayForeground(sound)
  }

  WaitForDownClick()

}


## Basic HTML report creation helpers
##
##

define OT(tag)
{
  return "<"+tag+">"
}

define CT(tag)
{
 return "</"+tag+">"
}

define H(text,level)
{
  tag <- "h"+level
  return OT(tag) + text + CT(tag)
}

define P(text)
{
  return OT("p") + text + CT("p")
}

define B(text)
{
 return "<b>"+text+"</b>"+CR(1)
}
define BR()
{
 return "<br>"
}
define HL()
{
  return "<hl>"
}

define Img(filename,width)
{
  return "<img src='"+filename+"' width="+width+"/>"
}
define PageHead()
{
 out <-  "<html>
<head>
  <link rel='stylesheet' href='../../paper.css'>

</head>
<body>"+
#<a href='#' onclick='window.print();return false;' title='Click to print this page'>Print this page</a>" +
 MakeDivPage(" <h1>Results from PEBL Cognitive Screening Test</h1>
   <pre>Participant/Patient Code: "+gSubNum+"</pre>
   <em>This test intended for screening for mild cognitive impairment.  It is not intended for self-diagnosis by untrained users. This test is inspired by tests included in commercial screening tests like the Montreal Cognitive Assessment and the Mini-mental state exam, but is developed independently.</em>
  <hl>
  <p><b>Test began:</b>  "+TimeStamp()+"</p>")

  return out
}

define PageEnd(scoretab,score,max,time)
{



   out <-H("Summary of PCST Test:",1) +
   Table(Second(scoreTab),First(scoretab))+

   P(B("Total score recorded on test: " ) +score + " of " + max )+
   P(B("Time to complete test:        " ) +Round(time/60000,2) + " min" )
   out <- MakeDivPage(out) + "</body></html>"


   return  out 
}
define Page(text)
{
  return     "<html><header></header><body> " + text +"</body></html>"
           
}

define Entag(tag,body)
{
  return OT(tag)+body+CT(tag)
}

define Table(tab,header:"")
{

 out <-   OT("table class='fl-table'")

if(IsList(header))
 {
   out <- out + "<thead><tr>"
   loop(item,header)
   {
     out <- out + "<th>"+item+"</th>"
   } 
   out <- out + "</tr></thead>"+CR(1)
 }

 loop(rowlist,tab)
 {
    row <- ""
    if(IsList(rowlist))
    {
      loop(item,rowlist)
      {
        row <- row +  Entag("td",item)
      }
    }
    out <- out + Entag("tr",row)
 }
 out <- out +   CT("table")

 return out
}



define ListMatches(l1,l2)
{
  
  high <- Max([Length(l1),Length(l2)])
  low <-  Min([Length(l1),Length(l2)])
  if(low == 0)
  {
    eql <- []
  } else{
  
  eql <- Repeat(0,high)
    
   loop(i,low)
    {
      Print(Nth(l1,i)+"=="+Nth(l2,i)+"?  " + ((Nth(l1,i)+"")==Nth(l2,i)+""))
      SetElement(eql,i,(Nth(l1,i)+"")==(Nth(l2,i)+""))
      Print(eql)
    }
   }
  return eql
}

define MakeDivPage(text)
{
  out <- "<div class='page'><div class='subpage'><p align='right'> Page " + gPage + " </p>"+
         text + "</div></div>"
  gPage <- gPage + 1

  return out
}


define WaitForDownClickWithTimeout(delay)
{
   endTime <- GetTime()+delay
   end <- 0
   left <- delay
   while(not end)
   {
      
      out <- WaitForMouseButtonWithTimeout(left)
      if(IsList(out))
      {
        end <- (Fourth(out)=="<pressed>")
	left <- endTime - GetTime()
      }else{
        end <- 1 ##timeout!
      }
   }
   return out
}


define ReadTranslationJSON(filename,lang)
{

  if(not FileExists(filename))
  {
    SignalFatalError("No translation file exists for ["+lang+"] ("+
      filename +")")
  }

  obj <- ParseJSON(FileReadText(filename))
  obj.language <- Lowercase(lang)


##we need to transform using formattext now.
 proplist <- GetPropertyList(obj)
 loop(prop,proplist)
 {
   if(IsText(GetProperty(obj,prop)))
   {
     text <- FormatText(GetProperty(obj,prop))
     SetProperty(obj,prop,FormatText(GetProperty(obj,prop)))
   }
 }

  return obj
}


##This makes a header label at the base font size, but scales down if it is too wide for the window.
define MakeHeader(text,x,y,window,size,maxwidth:0)
{ 

  if(maxwidth==0)
  {
   maxwidth <- window.width-25
  }

  itfits <- 0
  cursize <- size
  while(not itfits)
  {
      testlabel <- EasyLabel(text,x,y,window,cursize)

    if(testlabel.width > maxwidth)
    {
     cursize <- Max([5,cursize - 1])
    }else{
     itfits <- 1
    } 
  }

 return testlabel
}

define MakeConnector(startx,starty,endx,endy,width,color)
{

   
   connector <- MakeCustomObject("connector")
   connector.x <- (startx + endx)/2
   connector.y <- (starty+endy)/2
   connector.startx <- startx
   connector.starty <- starty
   connector.endx <- endx
   connector.endy <- endy
   connector.width <- width
   connector.color <- color

   connector.line <-  ThickLine(startx,starty,endx,endy,width,color)

  connector.Draw   <- "DrawConnector"
  connector.Inside <-"InsideConnector"
  connector.addobject <- "ADDCONNECTOR"
  connector.setcolor <-  "SETCONNECTORCOLOR"

  return connector
}

define SetConnectorColor(obj,color)
{
  obj.color <- color
  tl <-   obj.line
  tl.color <- color
}


define AddConnector(obj,win)
{
  AddObject(obj.line,win)

}

define DrawConnector(obj)
{
 Draw(obj.line)
}

##Check whether xy is 'inside' obj.
define InsideConnector(xy, obj)
{

   closest <- ClosestPoint(First(xy),Second(xy),obj.startx,obj.starty,
                                    obj.endx,obj.endy)

   dist <- Dist(xy,closest)
   return dist < (obj.width/2+1)

}


define ClosestPoint(px,py,x1,y1,x2,y2)
{

 ##if the two points are the same, just return one of them:
  if(x1==x2 and y1==y2)
    {
      ret <-  [x1,y1]
    } else{
  ## px,py is the point to test.
  ## x1,y1,x2,y2 is the line to calculate distance from
  ##
  ## Returns distance from the line, or if the intersecting point on the line nearest
  ## the point tested is outside the endpoints of the line, the distance to the
  ## nearest endpoint.
  ##
  ## Returns 9999 on 0 denominator conditions.
  ans <- "NA"
  ix <-0
  iy <- 0   # intersecting point
  lineMag <- Dist([x1, y1],[ x2, y2])  ##length of the line measuring to.
  
  
  if( lineMag < 0.00000001) {
    ##warning("short or zero-length segment; returning first point")
    ret <- [x1,y1]
  } else {
 
     ##calculate how far along the line segment the intersection point is:
     u <- (((px - x1) * (x2 - x1)) + ((py - y1) * (y2 - y1)))
     u <- u / (lineMag ^2)



#  if(u<.001) u <- .001
#  if(u>.999) u <- .999
    
  ##original code for using endpoint.
  if((u < 0.00001) or (u > .99999)) {
    ## closest point does not fall within the line segment, take the shorter distance
    ix <- ix
    iy <- iy

    ## to an endpoint
        l1  <- Dist([px, py], [x1, y1])
        l2  <- Dist([px, py], [x2, y2])
        
        if(l1 < l2)
          {
            ix <- x1
            iy <- y1
          }else {
            ix <- x2
            iy <- y2
          }
        

    
  } else {
    ## Intersecting point is on the line, use the formula
    ix <- x1 + u * (x2 - x1)
    iy <- y1 + u * (y2 - y1)
    
  }

  ret <- [ix,iy]
 }
}
return ret
}


##xy is the upper left of the dialog box.
define ConfirmDelete(x,y,msg:"Delete line?")
{

  minsize <- 100

  tfont <- MakeFont(gPEBLBaseFont,0,12,MakeColor("grey"),MakeColor("black"),0)


  text <- MakeLabel(msg,tfont)
  opt1 <- MakeLabel("Yes",tfont)
  opt2 <- MakeLabel("No",tfont)
  size <-  Max([minsize,text.width+6])

  bg <- Rectangle(x+50,y+30,size,60,MakeColor("grey20"),1)
  
  AddObject(bg,gWin)  
  AddObject(text,gWin); 
  Move(text,x+50 ,y+10)

  AddObject(opt1,gWin)
  AddObject(opt2,gWin)
  Move(opt1,x+30, y+40)
  Move(opt2,x+70, y+40)


 
  Draw()
  resp <-   WaitForClickOntarget([opt1,opt2],["yes","no"])

  RemoveObjects([text,opt1,opt2,bg],gWin)
  Draw()

  return resp
}


define OKBox(x,y,msg:"Ready to begin?")
{

  minsize <- 100

  tfont <- MakeFont(gPEBLBaseFont,0,12,MakeColor("grey"),MakeColor("black"),0)


  text <- MakeLabel(msg,tfont)
  opt1 <- MakeLabel("Yes",tfont)
  opt2 <- MakeLabel("No",tfont)
  size <-  Max([minsize,text.width+6])

  bg <- Rectangle(x+50,y+30,size,60,MakeColor("grey20"),1)
  
  AddObject(bg,gWin)  
  AddObject(text,gWin); 
  Move(text,x+50 ,y+10)

  AddObject(opt1,gWin)
  Move(opt1,x, y+40)



 
  Draw()
  resp <-   WaitForClickOntarget([opt1],["OK"])

  RemoveObjects([text,opt1,bg],gWin)
  Draw()

  return resp
}


define UpdateTimer(endtime,maxtime,timer,evt:0)
{

   #Print("UPDATING")

    prop <- Max([0,endTime - GetTime()])/maxtime
    front <- gTimer.front
    back <- gTimer.back
    text <- gTimer.text
    front.width <- back.width * prop
    text.text <- Ceiling((endTime-GetTime())/1000)
    Draw()
}


define EndTrial(p,evt:0)
{
 gKeeplooping <- 0
 Draw()
 return "<REMOVE>"
}



##redo this base function so we can implement the timer.

define WaitForMouseButtonWithTimeout(timeout)
{
    endtime <- GetTime() + timeout
    RegisterEvent("<MOUSE_BUTTON_PRESS>",1,1,"<EQUAL>","", [])


   RegisterEvent("<TIMER>", 1, endtime,"<GEQ>","",[])
   out <-   StartEventLoop()
   ClearEventLoop()
   
   return(out)

}


define WaitForMouseButton()
{

   RegisterEvent("<MOUSE_BUTTON_PRESS>",1,1,"<EQUAL>","", [])
   out <-   StartEventLoop()
   ClearEventLoop()  

   if(out=="<timeout>")
   {
     out <-[0,0,0,"<timeout>"]
   }
   return(out)

}


define Wait(time)
{


    ##register the timer
    endtime <- GetTime() + time
    RegisterEvent("<TIMER>", 1, endtime,"<GEQ>","",[])
    StartEventLoop()
    ClearEventLoop()

    
    return(1)
}

