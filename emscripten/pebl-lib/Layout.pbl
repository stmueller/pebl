## ----------------------------------------------------------------
## PEBL Layout & Response System
## Part of the PEBL Standard Library
##
## Provides unified layout and response handling with:
## - Zone-based layouts with automatic scaling
## - Platform-aware response modes (keyboard/mouse/touch)
## - Single-function API with intelligent defaults
## - Dynamic styling via nested property access
## - Theme support and accessibility features
##
## (c) 2025 Shane T. Mueller
## ----------------------------------------------------------------


## ================================================================
## Main API Functions
## ================================================================

define CreateLayout(testName, win, params:0)
{
    ## Creates a standard layout with header, stimulus region, footer, and response labels
    ## Returns layout object (also sets global gLayout for convenience)
    ##
    ## Args:
    ##   testName: Name of the test (for loading custom config)
    ##   win: Window object to create layout in
    ##   params: Parameter object (optional) with:
    ##     .responsemode - Response mode name (e.g., "spacebar", "auto")
    ##     .customkeys - Override keys (e.g., ["a", "b", "c"])
    ##     .customlabels - Override labels (e.g., ["Press A", "Press B", "Press C"])
    ##     .customsemantic - Override semantic values (e.g., ["left", "center", "right"])
    ##
    ## Example (basic):
    ##   layout <- CreateLayout("simon", gWin, gParams)
    ##   layout.header.text <- "Simon Task"
    ##
    ## Example (custom keys):
    ##   gParams.responsemode <- "singlekey"
    ##   gParams.customkeys <- ["<return>"]
    ##   gParams.customlabels <- ["ENTER"]
    ##   layout <- CreateLayout("mytest", gWin, gParams)

    ## Load configuration
    config <- LoadLayoutConfig(testName)
    modes <- LoadResponseModes()

    ## Determine response mode
    responseMode <- DetermineResponseMode(params, config, modes)

    ## Calculate screen scale
    scale <- CalculateScreenScale(config, win)

    ## Create layout object
    layout <- MakeCustomObject("Layout")
    layout.win <- win
    layout.config <- config
    layout.scale <- scale
    layout.responseMode <- responseMode
    layout.params <- params  ## Store params for access in CreateResponseLabels

    ## Calculate zone positions
    layout <- CalculateLayoutZones(layout)

    ## Create UI elements
    layout <- CreateLayoutElements(layout)

    ## Create response labels (only if mode is not "none")
    if(responseMode.type != "none")
    {
        layout <- CreateResponseLabels(layout, Round(config.zones.response.fontSize * scale))

        ## Hide footer if response mode requests it (e.g., touchtarget mode)
        if(PropertyExists(responseMode, "hideFooter"))
        {
            if(responseMode.hideFooter)
            {
                layout.footer.visible <- 0
            }
        }
    } else {
        ## No response UI - set empty lists and hide footer
        layout.responseLabels <- []
        layout.responseBorders <- []
        layout.footer.visible <- 0
    }

    ## Add top-level center coordinates for convenience
    ## (These duplicate stimulusRegion.centerX/Y for ease of use)
    layout.centerX <- layout.stimulusRegion.centerX
    layout.centerY <- layout.stimulusRegion.centerY

    ## Set global for convenience
    gLayout <- layout

    return(layout)
}


define WaitForLayoutResponse(layout, timeout: 0)
{
    ## Waits for response according to layout's response mode
    ## Returns semantic response: "left", "right", "up", "down", etc.
    ## Returns "<timeout>" if timeout exceeded
    ##
    ## Args:
    ##   layout: Layout object from CreateLayout()
    ##   timeout: Maximum wait time in ms (default 60000 = 60 seconds)
    ##
    ## Example:
    ##   resp <- WaitForLayoutResponse(gLayout, 5000)
    ##   if(resp == "left") { ## Handle left response }
    ##default -1 timeout indicates no timeout.
  

    mode <- layout.responseMode
    result <- "<timeout>"

    if(mode.type == "keyboard")
    {

        if(timeout==0)
	{
	  resp <- WaitForListKeyPress(mode.keys)
	} else{
          resp <- WaitForListKeyPressWithTimeout(mode.keys, timeout)
 	}

        if(resp != "<timeout>")
        {


            ## Map key to semantic name
            loop(i, Length(mode.keys))
            {


                if(resp == Nth(mode.keys, i))
                {

                    result <- Nth(mode.semantic, i)

                }
            }
        }
    }
    elseif(mode.type == "mousebutton")
    {
        ## WaitForMouseButton returns [x, y, button, state, ...]
        ## Only accept <pressed> events, not <released>
        ## Loop until we get a valid pressed event

        continue <- 1
        while(continue)
        {
            if(timeout==0)
            {
              resp <- WaitForMouseButton()
            }else{
              resp <- WaitForMouseButtonWithTimeout(timeout)
            }

            if(resp != "<timeout>")
            {
                ## Extract button number and state
                buttonNum <- Third(resp)
                buttonState <- Fourth(resp)

                Print("DEBUG mousebutton: button=" + buttonNum + " state=" + buttonState)

                ## Only process <pressed> events, skip <released>
                if(buttonState == "<pressed>")
                {
                    ## Map button to semantic name
                    loop(i, Length(mode.buttons))
                    {
                        if(buttonNum == Nth(mode.buttons, i))
                        {
                            result <- Nth(mode.semantic, i)
                            continue <- 0  ## Exit loop
                        }
                    }

                    ## If button not recognized, keep waiting
                    if(result == "<timeout>")
                    {
                        Print("DEBUG mousebutton: button " + buttonNum + " not in mode.buttons " + mode.buttons)
                    }
                }
                ## If <released>, continue loop to wait for next event
            } else {
                ## Timeout occurred
                continue <- 0
            }
        }
    } elseif(mode.type == "mousetarget")
    {
        ## Mouse target mode - wait for click on response border rectangles
        ## Create key list matching number of borders (1, 2, 3, ...)
        numBorders <- Length(layout.responseBorders)
        keylist <- Sequence(1, numBorders, 1)

        if(timeout==0)
	{
          resp <- WaitForClickOnTarget(layout.responseBorders, keylist)
	}else{

          resp <- WaitForClickOnTargetWithTimeout(layout.responseBorders, keylist,timeout)
	}

        if(resp != "<timeout>")
        {
            ## Return semantic name for clicked target
            result <- Nth(mode.semantic, resp)
        }
    } elseif(mode.type == "singlekey")
    {
        ## Single-key response mode - any key or mouse button counts as response
        ## Used for go-nogo and continuous performance tasks

        if(timeout==0)
        {
            resp <- WaitForListKeyPress(mode.keys)
        } else {
            resp <- WaitForListKeyPressWithTimeout(mode.keys, timeout)
        }

        if(resp != "<timeout>")
        {
            ## Return the single semantic value (e.g., "response")
            result <- First(mode.semantic)
        }
    } else {
        SignalFatalError("Unknown response mode: " + mode.type)
    }

    return(result)
}


## ================================================================
## Theme Functions
## ================================================================

define ApplyDarkTheme(layout)
{
    ## Applies dark theme to layout
    ## Black background with white text

    layout.win.bgcolor.red <- 40
    layout.win.bgcolor.green <- 40
    layout.win.bgcolor.blue <- 40

    layout.header.font.fgcolor <- MakeColor("white")
    layout.subheader.font.fgcolor <- MakeColor("white")
    layout.footer.font.fgcolor <- MakeColor("white")

    loop(label, layout.responseLabels)
    {
        label.font.fgcolor <- MakeColor("white")
        label.font.bgcolor.red <- 60
        label.font.bgcolor.green <- 60
        label.font.bgcolor.blue <- 60
    }

    Draw()
}


define ApplyHighContrastTheme(layout)
{
    ## Applies high contrast theme for accessibility
    ## Black text on yellow background

    layout.win.bgcolor <- MakeColor("yellow")

    layout.header.font.fgcolor <- MakeColor("black")
    layout.header.font.size <- Round(layout.header.font.size * 1.5)

    layout.subheader.font.fgcolor <- MakeColor("black")
    layout.footer.font.fgcolor <- MakeColor("black")

    loop(label, layout.responseLabels)
    {
        label.font.fgcolor <- MakeColor("black")
        label.font.size <- Round(label.font.size * 1.3)
        label.font.bgcolor <- MakeColor("white")
    }

    Draw()
}


define ApplyAccessibilitySettings(layout, params)
{
    ## Applies accessibility settings based on parameters
    ##
    ## Supported parameters:
    ##   params.highContrast: Enable high contrast mode
    ##   params.largeText: Increase all font sizes by 50%
    ##   params.colorBlind: Use black/white instead of colors

    if(PropertyExists(params, "highContrast"))
    {
        if(params.highContrast)
        {
            ApplyHighContrastTheme(layout)
        }
    }

    if(PropertyExists(params, "largeText"))
    {
        if(params.largeText)
        {
            layout.header.font.size <- Round(layout.header.font.size * 1.5)
            layout.subheader.font.size <- Round(layout.subheader.font.size * 1.5)
            layout.footer.font.size <- Round(layout.footer.font.size * 1.5)

            loop(label, layout.responseLabels)
            {
                label.font.size <- Round(label.font.size * 1.5)
            }

            Draw()
        }
    }

    if(PropertyExists(params, "colorBlind"))
    {
        if(params.colorBlind)
        {
            ## Ensure sufficient luminance contrast
            layout.win.bgcolor <- MakeColor("white")
            layout.header.font.fgcolor <- MakeColor("black")
            layout.subheader.font.fgcolor <- MakeColor("black")
            layout.footer.font.fgcolor <- MakeColor("black")

            loop(label, layout.responseLabels)
            {
                label.font.fgcolor <- MakeColor("black")
            }

            Draw()
        }
    }
}


## ================================================================
## Animation Functions
## ================================================================

define FlashCorrect(label, durationMs:500)
{
    ## Flashes label with green background to indicate correct response
    ##
    ## Args:
    ##   label: Label object to flash
    ##   durationMs: Duration of flash in milliseconds (default 500)

    ## Save original colors
    origBg <- label.font.bgcolor

    ## Flash green
    label.font.bgcolor <- MakeColor("green")
    Draw()
    Wait(durationMs)

    ## Restore
    label.font.bgcolor <- origBg
    Draw()
}


define FlashIncorrect(label, durationMs:500)
{
    ## Flashes label with red background to indicate incorrect response

    origBg <- label.font.bgcolor

    label.font.bgcolor <- MakeColor("red")
    Draw()
    Wait(durationMs)

    label.font.bgcolor <- origBg
    Draw()
}


define FadeOut(label, durationMs:1000)
{
    ## Fades out a label by animating alpha from 255 to 0
    ##
    ## Args:
    ##   label: Label object to fade
    ##   durationMs: Duration of fade in milliseconds (default 1000)

    steps <- 20
    stepDelay <- durationMs / steps

    loop(alpha, Sequence(255, 0, -13))
    {
        label.font.fgcolor.alpha <- alpha
        label.font.bgcolor.alpha <- alpha
        Draw()
        Wait(stepDelay)
    }
}


define FadeIn(label, durationMs:1000)
{
    ## Fades in a label by animating alpha from 0 to 255

    steps <- 20
    stepDelay <- durationMs / steps

    loop(alpha, Sequence( 0, 255, 13))
    {
        label.font.fgcolor.alpha <- alpha
        label.font.bgcolor.alpha <- alpha
        Draw()
        Wait(stepDelay)
    }
}


define PulseLabel(label, count:3, pulseSize:10)
{
    ## Pulses a label by increasing/decreasing font size
    ##
    ## Args:
    ##   label: Label object to pulse
    ##   count: Number of pulses (default 3)
    ##   pulseSize: Amount to increase size by (default 10)

    originalSize <- label.font.size

    loop(i,  count)
    {
        label.font.size <- originalSize + pulseSize
        Draw()
        Wait(150)

        label.font.size <- originalSize
        Draw()
        Wait(150)
    }
}


define HighlightResponse(label, durationMs:1000)
{
    ## Highlights a label by changing to yellow background with black text
    ##
    ## Args:
    ##   label: Label object to highlight
    ##   durationMs: Duration of highlight in milliseconds (default 1000)

    ## Cache original colors
    origBgColor <- label.font.bgcolor
    origFgColor <- label.font.fgcolor

    ## Highlight
    label.font.bgcolor <- MakeColor("yellow")
    label.font.fgcolor <- MakeColor("black")
    Draw()
    Wait(durationMs)

    ## Restore
    label.font.bgcolor <- origBgColor
    label.font.fgcolor <- origFgColor
    Draw()
}


## ================================================================
## Styling Helper Functions
## ================================================================

define SetLabelColor(label, colorName)
{
    ## Sets label foreground color by name
    ##
    ## Args:
    ##   label: Label object
    ##   colorName: Color name (e.g., "red", "blue", "green")

    label.font.fgcolor <- MakeColor(colorName)
    Draw()
}


define SetLabelBackground(label, red, green, blue, alpha:255)
{
    ## Sets label background color with RGBA values
    ##
    ## Args:
    ##   label: Label object
    ##   red, green, blue: Color components (0-255)
    ##   alpha: Alpha transparency (0-255, default 255)

    label.font.bgcolor.red <- red
    label.font.bgcolor.green <- green
    label.font.bgcolor.blue <- blue
    label.font.bgcolor.alpha <- alpha
    Draw()
}


define ScaleFont(label, scaleFactor)
{
    ## Scales label font size by a factor
    ##
    ## Args:
    ##   label: Label object
    ##   scaleFactor: Multiplier for font size (e.g., 1.5 = 150%)

    label.font.size <- Round(label.font.size * scaleFactor)
    Draw()
}


define StyleForDifficulty(layout, difficulty)
{
    ## Adjusts layout appearance based on difficulty level
    ##
    ## Args:
    ##   layout: Layout object
    ##   difficulty: "easy", "medium", or "hard"
    ##
    ## Easy: Large text, high contrast
    ## Medium: Normal text, slight fade
    ## Hard: Small text, more faded

    if(difficulty == "easy")
    {
        layout.header.font.size <- Round(60 * layout.scale)
        layout.header.font.fgcolor <- MakeColor("black")

        loop(label, layout.responseLabels)
        {
            label.font.size <- Round(32 * layout.scale)
        }
    }
    elseif(difficulty == "medium")
    {
        layout.header.font.size <- Round(48 * layout.scale)
        layout.header.font.fgcolor.alpha <- 220

        loop(label, layout.responseLabels)
        {
            label.font.size <- Round(24 * layout.scale)
        }
    }    else   { ## hard
        layout.header.font.size <- Round(36 * layout.scale)
        layout.header.font.fgcolor.alpha <- 180

        loop(label, layout.responseLabels)
        {
            label.font.size <- Round(18 * layout.scale)
        }
    }

    Draw()
}


## ================================================================
## Internal Helper Functions
## ================================================================

define LoadLayoutConfig(testName)
{
    ## Loads layout configuration from JSON file
    ## First checks for test-specific config, then falls back to default
    ##
    ## Returns configuration object with zones, margins, etc.

    config <- 0

    ## Try test-specific config first
    customPath <- "battery/" + testName + "/layout/" + testName + ".pbl.layout.json"

    if(FileExists(customPath))
    {
        config <- ParseJSON(FileReadText(customPath))
    }
    else
    {
        ## Fall back to default config
        defaultPath <- gPEBLBasePath + "media/settings/default-layout.json"

        if(FileExists(defaultPath))
        {
            config <- ParseJSON(FileReadText(defaultPath))
        }
        else
        {
            ## If no config files exist, return hardcoded defaults
            config <- GetDefaultLayoutConfig()
        }
    }

    return(config)
}


define MergeResponseModeTranslations(baseModes, overrideModes)
{
    ## Merges translation overrides into base response modes
    ##
    ## Override files contain only translated strings for each mode:
    ##   - labels: Array of translated label strings
    ##   - footerInstruction: Translated footer instruction string
    ##
    ## All other properties (type, keys, buttons, semantic, platforms, etc.)
    ## are preserved from the base modes
    ##
    ## Arguments:
    ##   baseModes: Base modes object with complete structure
    ##   overrideModes: Override modes object with translated strings only
    ##
    ## Returns:
    ##   Merged modes object with translations applied

    ## Get list of all mode names from base
    modeNames <- GetPropertyList(baseModes)

    ## For each mode, check if override exists and merge translations
    loop(modeName, modeNames)
    {
        baseMode <- GetProperty(baseModes, modeName)

        ## Check if override exists for this mode
        if(PropertyExists(overrideModes, modeName))
        {
            overrideMode <- GetProperty(overrideModes, modeName)

            ## Override labels if provided
            if(PropertyExists(overrideMode, "labels"))
            {
                baseMode.labels <- overrideMode.labels
            }

            ## Override footerInstruction if provided
            if(PropertyExists(overrideMode, "footerInstruction"))
            {
                baseMode.footerInstruction <- overrideMode.footerInstruction
            }

            ## Update the mode in baseModes
            SetProperty(baseModes, modeName, baseMode)
        }
    }

    return(baseModes)
}


define LoadResponseModes(lang:gLanguage)
{
    ## Loads response mode definitions using base+override pattern
    ##
    ## Architecture:
    ## 1. Always load baseline English file (complete structure)
    ## 2. Use 3-tier fallback to find language override file
    ## 3. Merge language-specific translations into base
    ##
    ## Override files contain only translated strings:
    ##   - labels: ["TRANSLATED_LABEL1", "TRANSLATED_LABEL2"]
    ##   - footerInstruction: "Translated instruction text"
    ##
    ## Arguments:
    ##   lang: Two-letter language code (default: gLanguage)
    ##
    ## Returns:
    ##   Response modes object with translated labels and footerInstructions

    ## Step 1: Always load baseline English file
    basePath <- gPEBLBasePath + "media/settings/response-modes.json"
    baseModes <- 0

    if(FileExists(basePath))
    {
        baseData <- ParseJSON(FileReadText(basePath))
        baseModes <- baseData.modes
    } else {
        ## Fall back to hardcoded defaults if base file not found
        baseModes <- GetDefaultResponseModes()
    }

    ## Step 2: Load language override file using 3-tier fallback
    lang <- Lowercase(lang)
    overrideModes <- 0

    ## Tier 1: Try explicit language if provided
    if(lang != "" and lang != "en")
    {
        overridePath <- gPEBLBasePath + "media/settings/response-modes/response-modes-" + lang + ".json"

        if(FileExists(overridePath))
        {
            overrideData <- ParseJSON(FileReadText(overridePath))
            overrideModes <- overrideData.modes
        } else {
            lang <- ""  ## Language file not available, fall back
        }
    }

    ## Tier 2: Try system locale if lang was empty or is English
    if((lang == "" or lang == "en") and overrideModes == 0)
    {
        systemLocale <- GetSystemLocale()

        if(systemLocale != "")
        {
            ## Extract language code from locale (e.g., "en_US" -> "en")
            lang <- Lowercase(SubString(systemLocale, 1, 2))

            ## Only load override if not English
            if(lang != "en")
            {
                overridePath <- gPEBLBasePath + "media/settings/response-modes/response-modes-" + lang + ".json"

                if(FileExists(overridePath))
                {
                    overrideData <- ParseJSON(FileReadText(overridePath))
                    overrideModes <- overrideData.modes
                }
            }
        }
    }

    ## Step 3: Merge language overrides into base modes
    if(overrideModes != 0)
    {
        baseModes <- MergeResponseModeTranslations(baseModes, overrideModes)
    }

    return(baseModes)
}


define DetermineResponseMode(params, config, modes)
{
    ## Determines which response mode to use based on parameters and platform
    ##
    ## Priority:
    ##   1. Parameter override (params.responsemode)
    ##   2. Config default
    ##   3. "auto" platform detection
    ##
    ## Custom key override:
    ##   If params.customkeys is provided, override mode's keys
    ##   If params.customlabels is provided, override mode's labels
    ##   If params.customsemantic is provided, override mode's semantic

    ## Get requested mode name
    modeName <- "auto"

    if(params != 0)
    {
        if(PropertyExists(params, "responsemode"))
        {
            modeName <- params.responsemode
        }
    }

    if(modeName == "auto")
    {
        if(PropertyExists(config, "responseDefaults"))
        {
            if(PropertyExists(config.responseDefaults, "type"))
            {
                modeName <- config.responseDefaults.type
            }
        }
    }

    ## If still auto, do platform detection
    if(modeName == "auto")
    {
        modeName <- GetPlatformResponseMode(modes)
    }

    ## Get mode configuration
    result <- 0
    if(PropertyExists(modes, modeName))
    {
        result <- GetProperty(modes, modeName)
    }
    else
    {
        SignalFatalError("Unknown response mode: " + modeName)
    }

    ## Apply custom key overrides if provided
    if(params != 0)
    {
        if(PropertyExists(params, "customkeys"))
        {
            result.keys <- params.customkeys
        }

        if(PropertyExists(params, "customlabels"))
        {
            result.labels <- params.customlabels
        }

        if(PropertyExists(params, "customsemantic"))
        {
            result.semantic <- params.customsemantic
        }
    }

    return(result)
}


define GetPlatformResponseMode(modes)
{
    ## Returns appropriate response mode for current platform
    ## Native: keyboard-shift
    ## Emscripten: keyboard-safe

    result <- "keyboardShift"

    if(GetSystemType() == "EMSCRIPTEN")
    {
        result <- "keyboardSafe"
    }

    return(result)
}


define CalculateScreenScale(config, win)
{
    ## Calculates scale factor based on actual screen size vs baseline
    ## Returns scale factor (1.0 = 800x600, 2.0 = 1600x1200, etc.)

    baselineWidth <- config.baseline.width
    baselineHeight <- config.baseline.height

    scaleX <- win.width / baselineWidth
    scaleY <- win.height / baselineHeight

    ## Use smaller scale to ensure everything fits
    scale <- Min([scaleX, scaleY])

    return(scale)
}


define CalculateLayoutZones(layout)
{
    ## Calculates position and dimensions for all layout zones
    ## Modifies layout object in-place
    ##
    ## Returns modified layout

    config <- layout.config
    scale <- layout.scale
    margins <- config.margins
    win <- layout.win

    ## Calculate scaled margins
    marginX <- Round(margins.x * scale)
    marginY <- Round(margins.y * scale)

    ## Calculate bottom reserve (no-go zone for windowed mode)
    bottomReserve <- 0
    if(PropertyExists(margins, "bottomReserve"))
    {
        bottomReserve <- Round(margins.bottomReserve * scale)
    }

    ## Available space (account for top margin, bottom margin, and bottom reserve)
    availWidth <- win.width - (2 * marginX)
    availHeight <- win.height - marginY - marginY - bottomReserve

    ## Calculate zone heights
    headerHeight <- 0
    subheaderHeight <- 0
    responseHeight <- 0
    footerHeight <- 0

    if(config.zones.header.visible)
    {
        headerHeight <- Round(config.zones.header.height * scale)
    }

    if(config.zones.subheader.visible)
    {
        subheaderHeight <- Round(config.zones.subheader.height * scale)
    }

    if(config.zones.response.visible)
    {
        responseHeight <- Round(config.zones.response.height * scale)
    }

    if(config.zones.footer.visible)
    {
        footerHeight <- Round(config.zones.footer.height * scale)
    }

    ## Stimulus region gets remaining space
    stimulusHeight <- availHeight - headerHeight - subheaderHeight - responseHeight - footerHeight

    ## Create stimulus region object
    stimRegion <- MakeCustomObject("StimulusRegion")
    stimRegion.x <- marginX
    stimRegion.y <- marginY + headerHeight + subheaderHeight
    stimRegion.width <- availWidth
    stimRegion.height <- stimulusHeight
    stimRegion.centerX <- marginX + (availWidth / 2)
    stimRegion.centerY <- stimRegion.y + (stimulusHeight / 2)

    layout.stimulusRegion <- stimRegion

    ## Store zone positions for UI creation
    layout.zones <- MakeCustomObject("Zones")
    layout.zones.header <- MakeCustomObject("Zone")
    layout.zones.header.y <- marginY
    layout.zones.header.height <- headerHeight

    layout.zones.subheader <- MakeCustomObject("Zone")
    layout.zones.subheader.y <- marginY + headerHeight
    layout.zones.subheader.height <- subheaderHeight

    layout.zones.response <- MakeCustomObject("Zone")
    layout.zones.response.y <- stimRegion.y + stimulusHeight
    layout.zones.response.height <- responseHeight

    layout.zones.footer <- MakeCustomObject("Zone")
    layout.zones.footer.y <- layout.zones.response.y + responseHeight
    layout.zones.footer.height <- footerHeight

    return(layout)
}


define CreateLayoutElements(layout)
{
    ## Creates UI elements (labels) for layout zones
    ## Modifies layout object in-place
    ##
    ## Returns modified layout

    config <- layout.config
    scale <- layout.scale
    win <- layout.win
    centerX <- win.width / 2

    ## Auto-detect foreground color based on window background
    ## (Same logic as EasyLabel)
    bgcol <- win.bgcolor
    val <- Max([bgcol.RED, bgcol.GREEN, bgcol.BLUE])

    if(val <= 100)
    {
        fgcol <- MakeColor("white")  ## Dark background
    } else {
        fgcol <- MakeColor("black")  ## Light background
    }

    ## Create header
    headerFont <- MakeFont(gPEBLBaseFont, 0,
                           Round(config.zones.header.fontSize * scale),
                           fgcol, MakeColor("white"), 0)
    header <- MakeLabel("", headerFont)
    AddObject(header, win)
    Move(header, centerX, layout.zones.header.y + (layout.zones.header.height / 2))
    header.visible <- config.zones.header.visible

    ## Create subheader
    subheaderFont <- MakeFont(gPEBLBaseFont, 0,
                              Round(config.zones.subheader.fontSize * scale),
                              fgcol, MakeColor("white"), 0)
    subheader <- MakeLabel("", subheaderFont)
    AddObject(subheader, win)
    Move(subheader, centerX, layout.zones.subheader.y + (layout.zones.subheader.height / 2))
    subheader.visible <- config.zones.subheader.visible

    ## Create footer
    footerFont <- MakeFont(gPEBLBaseFont, 0,
                           Round(config.zones.footer.fontSize * scale),
                           fgcol, MakeColor("white"), 0)
    footer <- MakeLabel("", footerFont)
    AddObject(footer, win)
    Move(footer, centerX, layout.zones.footer.y + (layout.zones.footer.height / 2))
    footer.visible <- config.zones.footer.visible

    ## Store in layout
    layout.header <- header
    layout.subheader <- subheader
    layout.footer <- footer
    layout.fgcol <- fgcol  ## Store auto-detected color for use in response labels

    return(layout)
}


define CreateResponseLabels(layout, fontSize)
{
    ## Creates response labels based on response mode with semantic-first architecture
    ## Modifies layout object in-place
    ##
    ## Returns modified layout

    mode <- layout.responseMode
    win <- layout.win
    fgcol <- layout.fgcol  ## Use auto-detected foreground color

    ## Get semantic labels from params, or default to mode semantic values
    semanticLabels <- []
    if(layout.params != 0)
    {
        if(PropertyExists(layout.params, "responselabels"))
        {
            semanticLabels <- layout.params.responselabels
        }
    }

    ## If not provided, default to capitalized semantic values
    if(Length(semanticLabels) == 0)
    {
        loop(sem, mode.semantic)
        {
            PushOnEnd(semanticLabels, Uppercase(sem))
        }
    }

    ## Format labels based on mode type
    displayLabels <- FormatLabelsForMode(mode, semanticLabels)

    ## Now create the actual label objects
    numLabels <- Length(displayLabels)

    ## Calculate spacing
    spacing <- win.width / (numLabels + 1)
    centerY <- layout.zones.response.y + (layout.zones.response.height / 2)

    ## Determine label styling based on mode type
    ## For mousetarget/touchtarget: create visible button borders
    ## For keyboard modes: use transparent background
    bgcolor <- MakeColor("lightgray")  ## Default: transparent
    borders <- []  ## Store border rectangles for mousetarget modes

    if(mode.type == "mousetarget")
    {
        ## Button-like appearance for clickable targets
        ## Create border rectangles with padding around text
        padding <- 20  ## Padding around text in pixels
        borderColor <- MakeColor("gray")
        fillColor <- MakeColor("white")
    }

    ## Create labels (and borders for mousetarget)
    labels <- []

    loop(i, numLabels)
    {
        ## For mousetarget: create border first (so it's behind the label)
        if(mode.type == "mousetarget")
        {
            ## Create temporary label to measure text dimensions
            tempFont <- MakeFont(gPEBLBaseFont, 0, fontSize,
                                  MakeColor("black"), bgcolor, 0)
            tempLabel <- MakeLabel(Nth(displayLabels, i), tempFont)
            AddObject(tempLabel, win)

            ## Get actual label dimensions
            labelWidth <- tempLabel.width
            labelHeight <- tempLabel.height

            ## Remove temp label
            RemoveObject(tempLabel, win)

            ## Minimum button size
            minWidth <- 120
            minHeight <- 50

            ## Use larger of minimum size or label size + margin
            borderWidth <- Max([minWidth, labelWidth + (padding * 2)])
            borderHeight <- Max([minHeight, labelHeight + (padding * 2)])

            ## Create filled rectangle with border (add to window FIRST so it's behind)
            border <- Rectangle(spacing * i, centerY,
                               borderWidth, borderHeight,
                               borderColor, 1)
            AddObject(border, win)
            PushOnEnd(borders, border)
        }

        ## Now create the actual label (added after border, so it's on top)
        ## For mousetarget: use black text on lightgray for high contrast button appearance
        if(mode.type == "mousetarget")
        {
            labelFont <- MakeFont(gPEBLBaseFont, 0, fontSize,
                                  MakeColor("black"), bgcolor, 0)
        } else {
            labelFont <- MakeFont(gPEBLBaseFont, 0, fontSize,
                                  fgcol, bgcolor, 0)
        }
        label <- MakeLabel(Nth(displayLabels, i), labelFont)
        AddObject(label, win)
        Move(label, spacing * i, centerY)

        PushOnEnd(labels, label)
    }

    layout.responseLabels <- labels
    layout.responseBorders <- borders  ## Store borders for cleanup/styling

    ## Set footer text - use footerInstruction if available, otherwise show labels
    if(PropertyExists(mode, "footerInstruction"))
    {
        layout.footer.text <- mode.footerInstruction
    } else {
        layout.footer.text <- JoinStrings(displayLabels, " | ")
    }

    return(layout)
}


define FormatLabelsForMode(mode, semanticLabels)
{
    ## Formats semantic labels based on response mode type
    ## Returns list of display labels
    ##
    ## Args:
    ##   mode: Response mode object
    ##   semanticLabels: List of semantic label strings (e.g., ["SAME", "DIFFERENT"])
    ##
    ## Returns:
    ##   List of formatted display labels

    displayLabels <- []

    if(mode.type == "keyboard")
    {
        ## Format: symmetric with keys on inside for 2-option modes
        ## For 2-option: "semantic key" (left) and "key semantic" (right)
        ## For other modes: "key (semantic)"

        numKeys <- Length(mode.keys)

        if(numKeys == 2)
        {
            ## Two-option mode: symmetric layout with keys on inside
            ## Left label: semantic key
            key <- FormatKeyName(Nth(mode.keys, 1))
            semantic <- Nth(semanticLabels, 1)
            PushOnEnd(displayLabels, semantic + " " + key)

            ## Right label: key semantic
            key <- FormatKeyName(Nth(mode.keys, 2))
            semantic <- Nth(semanticLabels, 2)
            PushOnEnd(displayLabels, key + " " + semantic)
        }
        else
        {
            ## More than 2 options: use standard format "KEY (semantic)"
            loop(i, numKeys)
            {
                key <- FormatKeyName(Nth(mode.keys, i))
                semantic <- Nth(semanticLabels, i)
                PushOnEnd(displayLabels, key + " (" + semantic + ")")
            }
        }
    }
    elseif(mode.type == "mousebutton")
    {
        ## Format: "BUTTON (semantic)" or just semantic for single-button modes
        ## Use mode.labels if available, otherwise fall back to GetButtonName
        loop(i, Length(mode.buttons))
        {
            buttonNum <- Nth(mode.buttons, i)
            semantic <- Nth(semanticLabels, i)

            ## For single-button modes, just show the semantic label
            if(Length(mode.buttons) == 1)
            {
                ## Single button - use label from mode if available, otherwise semantic
                if(PropertyExists(mode, "labels") and Length(mode.labels) > 0)
                {
                    PushOnEnd(displayLabels, Nth(mode.labels, i))
                } else {
                    PushOnEnd(displayLabels, semantic)
                }
            } else {
                ## Multiple buttons - show "BUTTON (semantic)" format
                if(PropertyExists(mode, "labels") and Length(mode.labels) > 0)
                {
                    buttonName <- Nth(mode.labels, i)
                } else {
                    buttonName <- GetButtonName(buttonNum)
                }
                PushOnEnd(displayLabels, buttonName + " (" + semantic + ")")
            }
        }
    }
    elseif(mode.type == "mousetarget")
    {
        ## Format: Just semantic (target is self-evident)
        displayLabels <- semanticLabels
    }
    elseif(mode.type == "singlekey")
    {
        ## Single key modes: use label from mode if available, otherwise semantic
        if(PropertyExists(mode, "labels") and Length(mode.labels) > 0)
        {
            displayLabels <- mode.labels
        } else {
            displayLabels <- semanticLabels
        }
    }
    else
    {
        ## Unknown mode type - default to semantic only
        displayLabels <- semanticLabels
    }

    return(displayLabels)
}


## ================================================================
## Fallback Default Configurations
## ================================================================

define GetDefaultLayoutConfig()
{
    ## Returns hardcoded default layout configuration
    ## Used when JSON config file is not found

    config <- MakeCustomObject("LayoutConfig")

    ## Baseline
    config.baseline <- MakeCustomObject("Baseline")
    config.baseline.width <- 800
    config.baseline.height <- 600

    ## Margins
    config.margins <- MakeCustomObject("Margins")
    config.margins.x <- 25
    config.margins.y <- 25
    config.margins.bottomReserve <- 25

    ## Zones
    config.zones <- MakeCustomObject("Zones")

    config.zones.header <- MakeCustomObject("Zone")
    config.zones.header.height <- 50
    config.zones.header.fontSize <- 28
    config.zones.header.visible <- 1

    config.zones.subheader <- MakeCustomObject("Zone")
    config.zones.subheader.height <- 25
    config.zones.subheader.fontSize <- 18
    config.zones.subheader.visible <- 1

    config.zones.response <- MakeCustomObject("Zone")
    config.zones.response.height <- 50
    config.zones.response.fontSize <- 20
    config.zones.response.visible <- 1

    config.zones.footer <- MakeCustomObject("Zone")
    config.zones.footer.height <- 50
    config.zones.footer.fontSize <- 16
    config.zones.footer.visible <- 1

    return(config)
}


define GetDefaultResponseModes()
{
    ## Returns hardcoded default response modes
    ## Used when JSON config file is not found

    modes <- MakeCustomObject("ResponseModes")

    ## keyboard-shift mode
    modes.keyboardShift <- MakeCustomObject("Mode")
    modes.keyboardShift.type <- "keyboard"
    modes.keyboardShift.keys <- ["<lshift>", "<rshift>"]
    modes.keyboardShift.labels <- ["LEFT-SHIFT", "RIGHT-SHIFT"]
    modes.keyboardShift.semantic <- ["left", "right"]

    ## keyboard-safe mode
    modes.keyboardSafe <- MakeCustomObject("Mode")
    modes.keyboardSafe.type <- "keyboard"
    modes.keyboardSafe.keys <- ["z", "/"]
    modes.keyboardSafe.labels <- ["Z", "/"]
    modes.keyboardSafe.semantic <- ["left", "right"]

    ## mousebutton mode
    modes.mousebutton <- MakeCustomObject("Mode")
    modes.mousebutton.type <- "mousebutton"
    modes.mousebutton.buttons <- [1, 3]
    modes.mousebutton.labels <- ["LEFT-CLICK", "RIGHT-CLICK"]
    modes.mousebutton.semantic <- ["left", "right"]

    ## mousetarget mode - click on labeled targets
    modes.mousetarget <- MakeCustomObject("Mode")
    modes.mousetarget.type <- "mousetarget"
    modes.mousetarget.labels <- ["Click LEFT", "Click RIGHT"]
    modes.mousetarget.semantic <- ["left", "right"]

    return(modes)
}

## ================================================================
## Semantic Label Formatting Functions
## ================================================================

define FormatKeyName(key)
{
    ## Convert key codes to display names
    result <- ""

    if(key == "<lshift>")
    {
        result <- "LEFT-SHIFT"
    }
    elseif(key == "<rshift>")
    {
        result <- "RIGHT-SHIFT"
    }
    elseif(key == "<space>")
    {
        result <- "SPACEBAR"
    }
    elseif(key == "<return>")
    {
        result <- "ENTER"
    }
    elseif(key == "<left>")
    {
        result <- "←"
    }
    elseif(key == "<right>")
    {
        result <- "→"
    }
    elseif(key == "<up>")
    {
        result <- "↑"
    }
    elseif(key == "<down>")
    {
        result <- "↓"
    }
    else
    {
        result <- Uppercase(key)
    }

    return(result)
}

define GetButtonName(buttonNum)
{
    ## Button numbers: 1=LEFT, 2=MIDDLE, 3=RIGHT
    buttonNames <- ["LEFT-CLICK", "MIDDLE-CLICK", "RIGHT-CLICK"]
    result <- ""

    if(buttonNum > 0 and buttonNum <= Length(buttonNames))
    {
        result <- Nth(buttonNames, buttonNum)
    } else {
        result <- "BUTTON-" + buttonNum
    }

    return(result)
}

define JoinStrings(list, separator)
{
    ## Join list of strings with separator
    result <- ""

    if(Length(list) == 0)
    {
        result <- ""
    } elseif(Length(list) == 1) {
        ## Single element - no separator needed
        result <- First(list)
    } else {
        result <- First(list)
        loop(i, Sequence(2, Length(list), 1))
        {
            result <- result + separator + Nth(list, i)
        }
    }

    return(result)
}
