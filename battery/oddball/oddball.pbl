########################################################################
## The PEBL OddBall Task
##
##
##
##  Method modeled roughly after one described by:
##
##
##
## Huettel, S. A., & McCarthy, G. (2004). What is odd in the oddball
##   task?:: Prefrontal cortex is activated by dynamic changes in
##   response strategy. Neuropsychologia, 42(3), 379-386.
##
##
##  Version 2.0, Released 2025 Shane T Mueller, Ph.D.
##  Version 1.0, Released 2011 Shane T Mueller, Ph.D.
##  http://pebl.sf.net
##  smueller@obereed.net
##
## From Huettel & McCarthy methods:
## The experimental task required subjects to classify rapidly
##presented stimuli on the basis of their shape (see Fig. 1). On
##each trial, a single circle or square was presented for 500 ms.
##The shapes subtended about 3◦ of visual angle (absolute size:
##∼2.5 cm; distance from eyes: ∼50 cm), and were presented
##either on the left or the right side of the screen, about 8◦ from
##fixation. Consecutive stimuli were separated by a 3000 ms
##stimulus-onset asynchrony. Each experimental run consisted
##of 122 stimuli (about 6 min), and subjects participated in
##between 8 and 10 runs (mean 9.33).
##The task required subjects to press a button with the left
##hand when a circle was presented and to press a button
##with the right hand when a square was presented. Subjects
##were instructed to respond as quickly as possible while
##maintaining a low error rate. On 90% of the experimental
##trials, the stimuli were presented on the same side of the
##screen as the hand of response. We refer to these trials
##as “standard” trials. However, on 10% of the trials, the
##stimuli were presented on the opposite side of the screen
##as the hand of the response. We refer to these trials as
##“strategy-change” trials, because they require subjects to
##inhibit use of a position-based strategy and to employ a
##shape-based strategy. Circles and squares were presented
##equally often, and the order of stimuli was randomized
##across trials. On average, there were 117 strategy-change tri-
##als per subject. The mean interval between successive strat-
##egy change trials was 9.3 stimuli (S.D. 9.0 stimuli).

########################################################################

define Start(p)
{
  ## Initialize upload system (works for both online and native)
  InitializeUpload()

  gScriptName <- "Oddball task"
  parpairs <- [["numreps",6],     ##this many reps of the 20-trial design
               ["soa",3000],      ##Fix the stimulus-onset asynchrony.
               ["responsemode","auto"]
               ]

   gParams <- CreateParameters(parpairs,gParamFile)

   numreps <- gParams.numreps
   soa <- gParams.soa

   gWin <- MakeWindow("black")
   Initialize()

   ##Get subject code if we need to:
   if(gSubNum+""=="0")
    {
	  gSubNum <- GetSubNum(gWin)
    }

   ## Create layout with response system AFTER GetSubNum
   gLayout <- CreateLayout("oddball", gWin, gParams)
   gLayout.header.text <- gStrings.header
   gLayout.subheader.visible <- 1

   ## Override response labels to show CIRCLE/SQUARE instead of LEFT/RIGHT
   leftLabel <- Nth(gLayout.responseLabels, 1)
   leftLabel.text <- gStrings.footerL
   rightLabel <- Nth(gLayout.responseLabels, 2)
   rightLabel.text <- gStrings.footerR

   ## Set footer to show the actual keys being used (from response mode)
   ## Format: "LEFT_KEY                                    RIGHT_KEY"
   leftKey <- Nth(gLayout.responseMode.labels, 1)
   rightKey <- Nth(gLayout.responseMode.labels, 2)
   gLayout.footer.text <- leftKey + "                                    " + rightKey
   Show(gLayout.footer)

   ## Show cursor only for mousetarget mode (need to click on targets)
   ## Hide cursor for keyboard, mousebutton, and touchtarget modes
   if(gParams.responsemode == "mousetarget")
   {
     ShowCursor(1)
   } else {
     ShowCursor(0)
   }

   ##Make data files

   header <- "subnum,block,time,trial,practice,targdir,oddballcoherence,oddballdir,time0,resp,corr,rt"
   gFileOut <- GetNewDataFile(gSubNum,gWin,"oddball","csv",header)
   gPooledFileOut <- FileOpenAppend("data/oddball-pooled.csv")


   gSumFileOut <- GetNewDataFile(gSubNum,gWin,"oddball-report","txt","")
   gLog <- FileOpenAppend("data/oddball-log.csv")
   gPooledSummary <- FileOpenAppend("data/oddball-all.csv")

   ##Add headers onto files.
   flen <- Length(FileReadList("data/oddball-pooled.csv"))


   if(flen==0)
    {
      FilePrint(gPooledFileOut, header)
    }

#   FilePrint(gFileOut,header)


   FilePrint(gLog, gSubNum + "," + gLanguage + "," +  TimeStamp()+",ODDBALL TASK,"+gResponseType+",INITIATED")
   DoInstructions()
   FilePrint(gLog, gSubNum + "," + gLanguage + "," + TimeStamp()+",ODDBALL TASK,"+gResponseType+",PRACTICE BEGIN")

   ##Create the stimuli blocks.  Each trial consists of:
   ##  a stimulus (square or circle)
   ##  - a target side (left or right)
   ## each round uses 122 trials.
   ## 90% are coherent
   ## 10% are 'oddballs'; with the wrong mappings.

   stim <- [1,2,1,2]
   side <- [-1,1,1,-1]
   times <- [9,9,1,1]

   basetrials <- Shuffle(RepeatList(RepeatLists(Transpose([stim,side]),times),numreps))



   ##Practice uses just a few trials
    practrials <- Shuffle(RepeatList([[1,-1],[1,-1],[2,1],
                                      [2,1],[1,1],[2,-1]],2))

    ##Set up some data holders
    gOddball    <- []
    gRTs        <- []
    gCorr       <- []

    ###########################################
    ## Calculate total trials for progress display
    gPracticeTrials <- Length(practrials)
    gTestTrials <- Length(basetrials)

    ###########################################
    ## Do the practice round
    gTrial <- 1
    gBlock <- 0
    gLayout.header.text <- gStrings.practice_header
    CountDown(gWin)

    endtime <- GetTime()

    loop(trial,practrials)
    {
      endtime  <- endtime+soa
      Trial(trial,1,endtime,gPracticeTrials)
      gTrial <- gTrial + 1
    }

    MessageKeyBox(gInterblock)

    ## Switch to test phase header and restart trial numbering
    gLayout.header.text <- gStrings.header
    gTrial <- 1

    CountDown(gWin)

    ###########################################
    ## Do the first test round
    FilePrint(gLog, gSubNum + "," + gLanguage + "," +   TimeStamp()+",ODDBALL TASK,"+gResponseType+",BLOCK 1 BEGIN")
    gBlock <- 1
    endtime <- GetTime()

    loop(trial,basetrials)
    {
      endtime  <- endtime+soa
      Trial(trial,0,endtime,gTestTrials)
      gTrial <- gTrial + 1
    }



   aggOddballRT <-SummaryStats(gRTs,gOddball)
   aggOddballAcc <-SummaryStats(gCorr,gOddball)

   oddballcost<- Nth(Second(aggoddballRT),4)-Nth(First(aggoddballRT),4)

   FilePrint(gSumFileOut,"-----------------------------------------------")
   FilePrint(gSumFileOut,"PEBL Oddball Task, Version 1.0")
   FilePrint(gSumFileOut,"http://pebl.sf.net")
   FilePrint(gSumFileOut,"Shane T. Mueller")
   FilePrint(gSumFileOut, GetPEBLVersion())
   FilePrint(gSumFileOut, GetSystemType())
   FilePrint(gSumFileOut, "Duration:  " + (GetTime()/1000/60) + " min")
   FilePrint(gSumFileOut,"-----------------------------------------------")
   FilePrint(gSumFileOut,"Screen width x height: " +gVideoWidth+ "x"+gVideoHeight)
   FilePrint(gSumFileOut, "Subject code: "+gSubNum)
   FilePrint(gSumFileOut, "Time:         "+TimeStamp())
   FilePrint(gSumFileOut,"-----------------------------------------------")

   FilePrint(gSumFileOut,"Total Errors:           "+(Length(gCorr)-Sum(gCorr)))
   FilePrint(gSumFileOut,"Mean Accuracy:          "+Mean(gCorr))
   FilePrint(gSumFileOut,"Mean response time:     "+Mean(gRTs))
   FilePrint(gSumFileOut,"Oddball cost (ms):     "+oddballcost)



   FilePrint(gSumFileOut,"Mean Response time (all trials) by Oddball type")
   FilePrint(gSumFileOut,"----------------------------------------")
   FilePrint(gSumFileOut,"Cond    N       median  mean    sd")
   FilePrint(gSumFileOut,"----------------------------------------")
   loop(i,aggOddballRT)
    {
      tmp <- ""
      loop(j,i)
       {
         tmp <- tmp + Format(j,7) + " "
       }
	   FilePrint(gSumFileOut,tmp)
    }
   FilePrint(gSumFileOut,"----------------------------------------")

   FilePrint(gSumFileOut," Accuracy by Oddball type")
   FilePrint(gSumFileOut,"----------------------------------------")
   FilePrint(gSumFileOut,"Cond    N       median  mean    sd")
   FilePrint(gSumFileOut,"----------------------------------------")
   loop(i,aggOddballAcc)
    {
      tmp <- ""
      loop(j,i)
       {
         tmp <- tmp + Format(j,7) + " "
       }
	   FilePrint(gSumFileOut,tmp)
    }
   FilePrint(gSumFileOut,"----------------------------------------")


   Draw()


   datalist <- Flatten([[Mean(gCorr),Mean(gRTS),oddballcost],
                Fourth(Transpose(aggOddballRT)),
	        	Fourth(Transpose(aggOddballAcc))])


   FilePrint(gPooledSummary,gSubNum+","+TimeStamp()+datalist)
   FilePrint(gLog, gSubNum + "," + gLanguage + "," + TimeStamp()+",ODDBALL TASK,"+gResponseType+",EXPERIMENT COMPLETE")

   ## Upload data files (works online, no-op on native)
   UploadFile(gSubNum, "data/" + gSubNum + "/oddball-" + gSubNum + ".csv")
   UploadFile(gSubNum, "data/" + gSubNum + "/oddball-report-" + gSubNum + ".txt")
   UploadFile(gSubNum, "data/oddball-pooled.csv")
   UploadFile(gSubNum, "data/oddball-log.csv")
   UploadFile(gSubNum, "data/oddball-all.csv")

  MessageKeyBox(gDebrief)

}

define Trial (stim,practice,trialend,totalTrials)
{
   ## Update subheader with trial progress
   gLayout.subheader.text <- "Trial " + gTrial + " of " + totalTrials

   time0 <- GetTime()

   ## Center stimuli in stimulus region to avoid footer overlap
   ycenter <- gLayout.stimulusRegion.y + gLayout.stimulusRegion.height/2
   fixation <- EasyLabel("+",gVideoWidth/2,ycenter,gWin,40)
   ## Footer already set in layout

   Draw()

   targID <- First(stim) #1=circle,2=square
   side <- Second(stim)  #-1=left,+1=right

   oddball <- (targID==1 and side==1 ) or (targID==2 and side==-1)

    xval <- gVideoWidth/2 + side * 200

    if(targID==1)
      {
	     stim <- Circle(xval, ycenter,75,MakeColor("red"),1)
      } else {
	     stim <- Square(xval, ycenter,150,MakeColor("red"),1)
      }

    AddObject(stim,gWin)
    ##Now, how the trial sequence.

	Draw()

    time1 <- GetTime()
    gStimOn <- 1
    RegisterEvent("<TIMER>", 1, time1+500,"<GEQ>","HIDEME", [stim])
    resp <- WaitForLayoutResponse(gLayout, 2500)
    time2 <- GetTime()
    Hide(stim)

    corr <- ((targID ==2) and (resp == "right")) or
            ((targID ==1) and (resp == "left"))
    rt <- time2-time1

    if(practice)
     {
         if(corr)
		    {
              fixation.text  <- gCorrect + " ["+rt+"]"
            } else {
              fixation.text  <- gIncorrect+ " ["+rt+"]"
            }
			Show(fixation)
			Draw()
			Wait(400)

     }
   Draw()
   dataline <- gSubNum + ","+ gBlock +","+GetTime() +"," +gTrial+","+practice+","+
               targID+","+side+","+ oddball+","+time0+","+resp+","+corr+","+rt

   FilePrint(gFileOut,dataline)
   FilePrint(gPooledFileOut,dataline)

   if(not practice)
    {
      gOddball <- Append(gOddball,oddball)
      gRTs        <- Append(gRTS,rt)
      gCorr       <- Append(gCorr,corr)

   }

  RemoveObject(stim,gWin)
  RemoveObject(fixation,gWin)

  WaitUntil(trialend)
  return resp
}

define HideMe(stim,evt:0)
{
  if(gStimOn)
  {
     Hide(stim)
	 gStimOn <- 0
	 Draw()
  }

  return "<REMOVE>"
}


define ShowAll(list,hideshow)
{
   loop(i,list)
   {
     i.visible <- hideshow
   }
}


##This creates a full factorial design with each sublist of list
##as a factor.
define CrossFactors(list)
{

  factors <- First(list)
  size <- 2
  loop(factor,SubList(list,2,Length(list)))
  {
     tmp <-DesignFullCounterbalance(factors,factor)
	 factors <- FoldList(Flatten(tmp),size)
	 size <- size + 1
  }
  return factors
}


define GetStrings(lang)
{
  gStrings <- GetTranslations("oddball", lang)

   gCorrect <- gStrings.correct
   gIncorrect <- gStrings.incorrect
   gInst1Text <- gStrings.inst1text
   gInst2Text <- gStrings.inst2text
   gInst3text <- gStrings.inst3text

   gFooterl <- gStrings.footerL
   gFooterR <- gStrings.footerR
   gInterblock <- gStrings.interblock
   gDebrief <- gStrings.debrief

}



define Initialize()
{


  gResponseType <-"shiftkeys"  ##currently, changing this has no effect.
  gSleepEasy <- 1
  GetStrings(gLanguage)

  ##  The screen re
  ##
  ##gVideoWidth <- 800
  ##gVideoheight <- 600

  ## the yoffset is supposed to be 1.06 degrees above offset.
  ##
  ##-\                                       X
  ##  \                                      |
  ##  #|          tan(1.06) = rise/distance  |
  ##  #|-------------------------------------X
  ##  #|
  ##  /           rise = tan(1.06)*distance
  ##_/
  ##

  ##default to 17" 3x4 screen.  Adjust to suit.
  screenheight <- 10.2   ## 10.2 inches high
  eyedistance  <- 30     ##assume 30" from screen.
  pixelsperunit <- gVideoHeight/screenheight
  eyepixeldistance <- eyedistance * pixelsperunit

  ##this is the vertical offset
  gOffset <-  Round(Tan(DegToRad(1.06)) * eyepixeldistance)

   if(not FileExists("data"))
    {
       MakeDirectory("data")

    } elseif(not IsDirectory("data"))
    {
       SignalFatalError("File named 'data' exists.  Remove so data directory can be created.")
    }



}


define MessageKeyBox(message)
{
  ## Use AdaptiveTextBox to fit within stimulus region
  ## Automatically adapts if text doesn't fit
  tb <- AdaptiveTextBox(message,
                        gLayout.stimulusRegion.x + 20,
                        gLayout.stimulusRegion.y + 20,
                        gWin, 56,
                        gLayout.stimulusRegion.width - 40,
                        gLayout.stimulusRegion.height - 40,
                        "scalefont")
  Draw()
  WaitForLayoutResponse(gLayout)
  RemoveObject(tb,gWin)

}

define DoInstructions()
{
   ## Hide header during instructions, but keep footer and response labels visible
   gLayout.header.visible <- 0
   Draw()

   ## Use AdaptiveTextBox at top of screen with small margin
   ## Height of ~150 pixels for instructions, leaving room for stimuli below
   ## Position from upper-left corner (x=20, y=20)
   tb <- AdaptiveTextBox(gInst1text, 20,   20,
                         gWin, 32, gVideoWidth - 40,  150,
                         "scalefont")

   ## Position stimuli below the textbox (textbox ends at ~170, place stimuli at ~300)
   ycenter <- gLayout.centerY
   xcenter <- gLayout.centerX
   fixation <- EasyLabel("+",xcenter,ycenter,gWin,40)
   ## First page shows typical case: circle left, square right (matching response labels)
   stim1 <- Circle(xcenter-200, ycenter,75,MakeColor("red"),1)
   stim2 <- Square(xcenter+200, ycenter,150,MakeColor("red"),1)
   AddObject(stim1,gWin)
   AddObject(stim2,gWin)
   Draw()
   WaitForLayoutResponse(gLayout)

   ## Second page shows oddball case: circle right, square left
   tb.text <- gInst2text
   stim1.x <- gVideoWidth/2+200
   stim2.x <- gVideoWidth/2-200
   Draw()
   WaitForLayoutResponse(gLayout)

   tb.text <- gInst3text
   Draw()
   WaitForLayoutResponse(gLayout)
   RemoveObject(stim1,gWin)
   RemoveObject(stim2,gWin)
   RemoveObject(fixation,gWin)
   RemoveObject(tb,gWin)

   ## Restore header visibility (footer and response labels stayed visible)
   gLayout.header.visible <- 1
   Draw()
}



define WaitUntil(time)
{

     RegisterEvent("<TIMER>", 1, time,"<GEQ>","", [])
     StartEventLoop()  #Start the timer
     ClearEventLoop()  #clear it out when done.

}


define RepeatLists(lists,times)
{

  base <- Transpose([lists,times])
   tmp <- []
   loop(i,base)
   {
     tmp <- Merge(tmp, Repeat(First(i),Second(i)))
   }
 return tmp
}
