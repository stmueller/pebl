## Test isometric diagonal segmentation with clear separation
define Start(p)
{
  gGridSize <- 20
  gWin <- MakeWindow("black")

  ## Create test diagonals with clear separation
  ## Format: "startIndex;endIndex"

  ## Test 1: NW diagonal, even-to-even, length 4
  ## From (row=2, col=2) to (row=4, col=6)
  test1_start <- 2 * 20 + 2 + 1  ## = 43
  test1_end <- 4 * 20 + 6 + 1    ## = 87
  test1 <- test1_start + ";" + test1_end

  ## Test 2: NW diagonal, odd-to-odd, length 4
  ## From (row=6, col=3) to (row=8, col=7)
  test2_start <- 6 * 20 + 3 + 1  ## = 124
  test2_end <- 8 * 20 + 7 + 1    ## = 168
  test2 <- test2_start + ";" + test2_end

  ## Test 3: NE diagonal, even-to-even, length 4
  ## From (row=10, col=10) to (row=12, col=6)
  test3_start <- 10 * 20 + 10 + 1  ## = 211
  test3_end <- 12 * 20 + 6 + 1     ## = 247
  test3 <- test3_start + ";" + test3_end

  ## Test 4: NE diagonal, odd-to-odd, length 4
  ## From (row=14, col=11) to (row=16, col=7)
  test4_start <- 14 * 20 + 11 + 1  ## = 292
  test4_end <- 16 * 20 + 7 + 1     ## = 328
  test4 <- test4_start + ";" + test4_end

  ## Test 5: NW diagonal, even-to-even, length 2
  ## From (row=2, col=12) to (row=3, col=14)
  test5_start <- 2 * 20 + 12 + 1   ## = 53
  test5_end <- 3 * 20 + 14 + 1     ## = 75
  test5 <- test5_start + ";" + test5_end

  ## Test 6: NW diagonal, odd-to-odd, length 2
  ## From (row=6, col=13) to (row=7, col=15)
  test6_start <- 6 * 20 + 13 + 1   ## = 134
  test6_end <- 7 * 20 + 15 + 1     ## = 156
  test6 <- test6_start + ";" + test6_end

  ## Combine into single diagram string
  diagram <- test1 + "|" + test2 + "|" + test3 + "|" + test4 + "|" + test5 + "|" + test6

  Print("Test diagram: " + diagram)
  Print("")

  ## Parse and segment
  segments <- ParseDiagram(diagram)
  Print("Parsed " + Length(segments) + " segments")
  Print("")

  segmented <- SegmentGraph(segments, "isometric", gGridSize)

  ## Display
  Print("")
  Print("Calling ShowTestDiagram...")
  ShowTestDiagram(segments, segmented)
  Print("Done!")
}

## Parse diagram string (copied from main script)
define ParseDiagram(diagramStr)
{
  segments <- []
  if(StringLength(diagramStr) > 0)
  {
    segStrs <- SplitString(diagramStr, "|")
    loop(segStr, segStrs)
    {
      points <- SplitString(segStr, ";")
      if(Length(points) == 2)
      {
        start <- ToNumber(First(points))
        end <- ToNumber(Second(points))
        PushOnEnd(segments, [start, end])
      }
    }
  }
  return(segments)
}

## Segment graph (copied from main script)
define SegmentGraph(segments, type, lgridsize)
{
  result <- []
  loop(seg, segments)
  {
    start <- First(seg)
    end <- Second(seg)
    subsegs <- ReduceSegment(start, end, lgridsize, type)
    loop(subseg, subsegs)
    {
      PushOnEnd(result, subseg)
    }
  }
  return(result)
}

## ReduceSegment (copied from main script)
define ReduceSegment(start, end, lgridsize, type)
{
  startRow <- Floor((start - 1) / lgridsize)
  startCol <- Mod(start - 1, lgridsize)
  endRow <- Floor((end - 1) / lgridsize)
  endCol <- Mod(end - 1, lgridsize)

  startX <- startCol
  startY <- startRow
  endX <- endCol
  endY <- endRow

  deltaX <- endX - startX
  deltaY <- endY - startY

  Print("DIAGONAL " + start + ";" + end + ": Row " + startRow + " col " + startCol + " → Row " + endRow + " col " + endCol + " | dX=" + deltaX + " dY=" + deltaY)

  step <- 0
  if(deltaX == 0 or deltaY == 0)
  {
    step <- Max([Abs(deltaX), Abs(deltaY)])
  } else {
    if(type == "isometric")
    {
      if(Abs(deltaX) == 2 * Abs(deltaY))
      {
        step <- Abs(deltaX)
        Print("  → ISO DIAGONAL (1:2): step=" + step)
      } else {
        if(Abs(deltaX) == Abs(deltaY))
        {
          step <- Abs(deltaX)
          Print("  → ISO DIAGONAL (1:1): step=" + step)
        } else {
          step <- 0
          Print("  → NOT iso diagonal")
        }
      }
    } else {
      step <- GCD(Abs(deltaX), Abs(deltaY))
    }
  }

  segments <- []

  if(step == 0)
  {
    segments <- [[start, end]]
  } else {
    stepX <- deltaX / step
    stepY <- deltaY / step

    Print("  → stepX=" + stepX + " stepY=" + stepY)

    points <- []

    i <- 0
    while(i <= step)
    {
      colRaw <- startX + i * stepX
      rowRaw <- startY + i * stepY

      colInt <- Floor(colRaw + 0.5)
      rowInt <- Floor(rowRaw)
      if(Mod(colInt, 2) == 0)
      {
        rowInt <- Floor(rowRaw + 0.5)
      }

      index <- rowInt * lgridsize + colInt + 1

      Print("    Step " + i + ": col=" + colRaw + " row=" + rowRaw + " → (r=" + rowInt + ",c=" + colInt + ") index " + index)

      PushOnEnd(points, index)

      i <- i + 1
    }

    Print("  → Generated " + Length(points) + " points: " + points)

    i <- 1
    while(i < Length(points))
    {
      PushOnEnd(segments, [Nth(points, i), Nth(points, i+1)])
      i <- i + 1
    }

    if(Length(segments) == 0)
    {
      segments <- [[start, end]]
    }
  }

  return(segments)
}

define GCD(a, b)
{
  a <- Abs(a)
  b <- Abs(b)
  while(b > 0)
  {
    temp <- b
    b <- Mod(a, b)
    a <- temp
  }
  return(a)
}

## Display test diagram
define ShowTestDiagram(rawSegs, segmentedSegs)
{
  titleFont <- MakeFont(gPEBLBaseFontMONO, 0, 32, MakeColor("white"), MakeColor("black"), 1)

  gridLeft <- 200
  gridRight <- gVideoWidth - 200
  gridTop <- 150
  gridBottom <- gVideoHeight - 150

  ## RAW view
  Draw()
  title1 <- MakeLabel("Isometric Diagonal Test - RAW", titleFont)
  AddObject(title1, gWin)
  Move(title1, gVideoWidth/2, 40)

  mygrid1 <- MakeDisplayGrid(gWin, gGridSize, gGridSize, gridLeft, gridRight, gridTop, gridBottom, 3, "grey30", "isometric")

  yellowColor <- MakeColorRGB(255, 255, 0)
  loop(seg, rawSegs)
  {
    DrawSegment(seg, mygrid1, yellowColor, 3)
  }

  Draw()
  WaitForAnyKeyPress()

  ## SEGMENTED view
  Draw()
  title2 <- MakeLabel("Isometric Diagonal Test - SEGMENTED", titleFont)
  AddObject(title2, gWin)
  Move(title2, gVideoWidth/2, 40)

  mygrid2 <- MakeDisplayGrid(gWin, gGridSize, gGridSize, gridLeft, gridRight, gridTop, gridBottom, 3, "grey30", "isometric")

  loop(seg, segmentedSegs)
  {
    DrawSegment(seg, mygrid2, yellowColor, 3)
  }

  Draw()
  WaitForAnyKeyPress()
}

define MakeDisplayGrid(win, width, height, xmin, xmax, ymin, ymax, circsize, color, style)
{
  yminTmp <- ymin
  col <- MakeColor(color)

  xDelta <- (xmax - xmin) / (width - 1)
  yDelta <- (ymax - ymin) / (height - 1)

  odd <- 1
  points <- []

  loop(j, Sequence(1, height, 1))
  {
    loop(i, Sequence(1, width, 1))
    {
      if(style == "isometric")
      {
        if(odd)
        {
          ymin <- yminTmp + yDelta / 4
        } else {
          ymin <- yminTmp - yDelta / 4
        }
        odd <- 1 - odd
      }

      point <- Circle(xmin + xDelta * (i - 1), ymin + yDelta * (j - 1), circsize, col, 1)
      point.aa <- 1
      AddObject(point, win)
      PushOnEnd(points, point)
    }
  }

  gridObj <- MakeCustomObject("grid")
  gridObj.points <- points
  gridObj.win <- win

  return(gridObj)
}

define DrawSegment(seg, mygrid, color, width)
{
  startIdx <- First(seg)
  endIdx <- Second(seg)

  startPoint <- Nth(mygrid.points, startIdx)
  startX <- startPoint.x
  startY <- startPoint.y

  endPoint <- Nth(mygrid.points, endIdx)
  endX <- endPoint.x
  endY <- endPoint.y

  line <- ThickLine(startX, startY, endX, endY, width, color)
  line.aa <- 1
  AddObject(line, gWin)

  startCirc <- Circle(startX, startY, width, color, 1)
  startCirc.aa <- 1
  AddObject(startCirc, gWin)

  endCirc <- Circle(endX, endY, width, color, 1)
  endCirc.aa <- 1
  AddObject(endCirc, gWin)
}
