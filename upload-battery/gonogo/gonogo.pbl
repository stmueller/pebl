##  PEBL Go-Nogo task
##  Designed after method described in:
##  Bezdjian, S. Baker, L. A., Lozano, D. I & Raine, A. (2009).
##    Assessing inattention and impulsivity in children during the Go/NoGo task
##    Br J Dev Psychol. 2009 June 1; 27(2): 365â€“383.
##    doi: 10.1348/026151008X314919.
##    http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2757760/
##
##  Croation translation (HR) By Silvija Rucevicgon
##  Italian translation (IT) by Antonella Somma

define Start(p)
{
  InitializeUpload()  ## Initialize token-based hosting if upload.json exists
  ##default values to use if .par file is not found
  parpairs <- [["reps",32], ##Number of repetitions of P/R blocks (with trials shuffled)
               ["isi",1500], ##Time between stimuli
	       ["pStim","P"],
	       ["rStim","R"],
               ["numTarg", 4],  ##Number of 'p' trials per block
	       ["numFoil", 1],  ##Number of 'R' trials per block
               ["stimtime",500],
	       ["color","blue"], ##color of stimulus.
	       ["useBJDP",1 ],    ##use 80% targets in both rounds, as in the original BJDP paper.
               ["responsemode","spacebar"]]  ##Single-key response mode (spacebar, leftclick, touchscreen, clicktarget)

 gParams <- CreateParameters(parpairs,gParamFile)
 PrintProperties(gParams)

 reps <-gParams.reps   ##number of repetitions of the PPPPR design
 gisi <- gParams.isi  ##inter-stimulus interval

  gWin <- MakeWindow("black")

  gSleepEasy <- 1

   ##Get subject code if we need to:
   if(gSubNum+""=="0")
    {
	  gSubNum <- GetSubNum(gWin)
    }

  GetStrings(gLanguage)

  ## Set semantic label BEFORE CreateLayout so border is sized correctly
  ## Must be set before CreateLayout because border size is calculated from label dimensions
  if(gParams.responsemode == "spacebar")
  {
    gParams.responselabels <- [gStrings.label_spacebar]
  } elseif(gParams.responsemode == "leftclick") {
    gParams.responselabels <- [gStrings.label_leftclick]
  } elseif(gParams.responsemode == "touchscreen") {
    gParams.responselabels <- [gStrings.label_touchscreen]
  } elseif(gParams.responsemode == "clicktarget") {
    gParams.responselabels <- [gStrings.label_clicktarget]
  } else {
    ## Default fallback
    gParams.responselabels <- [gStrings.respond_label]
  }

  ## Create layout with response system (determines actual mode)
  gLayout <- CreateLayout("gonogo", gWin, gParams)

  ## Show/hide cursor based on response mode
  if(gParams.responsemode == "clicktarget" or gParams.responsemode == "leftclick" or gParams.responsemode == "touchscreen")
  {
    ShowCursor(1)  ## Show cursor for mouse modes
  } else {
    ShowCursor(0)  ## Hide cursor for keyboard modes
  }

  ## Store reference to response label for feedback
  if(Length(gLayout.responseLabels) > 0)
  {
    gResponseLabel <- First(gLayout.responseLabels)
  }

  ## For mousetarget modes: widen border to accommodate bold text feedback
  ## (gonogo makes text bold on response, which expands it)
  if(Length(gLayout.responseBorders) > 0)
  {
    gResponseBorder <- First(gLayout.responseBorders)
    ## Add 50 pixels to width to accommodate bold text expansion
    gResponseBorder.width <- gResponseBorder.width + 50
  }

  gLayout.header.visible <- 0
  gLayout.subheader.visible <- 0
  gLayout.footer.visible <- 0

   gFileOut <- GetNewDataFile(gSubNum,gWin,"gonogo","csv",
 "subnum,block,type,correctresponse,trial,choice,x,y,stim,present,response,responded,corr,starttime,rt")

   gPooledFileOut <- FileOpenAppend("data/gonogo-pooled.csv")
   gSumFileOut <-GetNewDataFile(gSubNum,gWin,"gonogo-report","txt","")

   gLog <- FileOpenAppend("data/gonogo-log.csv")
   gPooledSummary <- FileOpenAppend("data/gonogo-all.csv")
   FilePrint(gLog, gSubNum + "," + gLanguage + "," + TimeStamp()+",GONOGO,INITIATED")

  ##Keep track of some data
  gBlockNums <- []
  gRTs <- []
  gErrors <- []
  gStim <- []
  gResponded <- []

   design1 <- Merge(Repeat(gParams.pstim,gParams.numTarg),
                  Repeat(gParams.rstim,gParams.numFoil))
   design2 <- Merge(Repeat(gParams.rstim,gParams.numTarg),
                  Repeat(gParams.pstim,gParams.numFoil))

	design <- design1
  practice <-  Shuffle(RepeatList(design,2))

  gBlock <- 0
  ShowInstructions(gInst1, gParams.pstim, gParams.rstim, gParams.color)
  CountDown(gWin)
  FilePrint(gLog, gSubNum + "," + gLanguage + "," + TimeStamp()+",GONOGO,ROUND1 Start")
  DoBlock(practice,gParams.pstim,"practice",gParams.color)

  #The stimuli are the same for both blocks of trials.
  stim <- Shuffle(RepeatList(design,reps))


 #Condition 1 is the 'P-Go' condition, with 160 trials
  gBlock <- 1
  MessageKeyBox(gInst2)
  CountDown(gWin)
   FilePrint(gLog, gSubNum + "," + gLanguage + "," + TimeStamp()+",GONOGO,ROUND2 Start")
  DoBlock(stim,gParams.pstim,"test",gParams.color)
  stim <- Shuffle(stim)

  if(gParams.useBJDP)
  {
    design <- design2
  }


##Do a second practice block
   practice <-  Shuffle(RepeatList(design,2))
   stim <- Shuffle(RepeatList(design,reps))


    gBlock <- 2
    ShowInstructions(gInst3, gParams.rstim, gParams.pstim, gParams.color)
   CountDown(gWin)
   FilePrint(gLog, gSubNum + "," + gLanguage + "," + TimeStamp()+",GONOGO,ROUND3 Start")
   DoBlock(practice,gparams.rstim,"practice",gParams.color)


 #Condition 2 is the R-Go condition
 gBlock <- 3
 MessageKeyBox(gInst2)
 CountDown(gWin)
  FilePrint(gLog, gSubNum + "," + gLanguage + "," + TimeStamp()+",GONOGO,ROUND4 Start")
  DoBlock(stim,gparams.rstim,"test",gParams.color)


   FilePrint(gLog, gSubNum + "," + gLanguage + "," + TimeStamp()+",GONOGO,DONE")
  ##We want to report:
  ##P-go errors (round 1)
  ##R-go errors (round 2)
  ##R-nogo errors (round 1)
  ##P-nogo errors (round 2)

  ## P-go rt (round 1)
  ## R-go RT (round 2)

  round1<- Match(gBlockNums,1)
  err1 <- Filter(gErrors,round1)
  rt1 <- Filter(gRTs,round1)
  stim1 <- Filter(gStim,round1)
  resp1 <- Filter(gResponded,round1)

  round2<- Match(gBlockNums,3)
  err2 <- Filter(gErrors,round2)
  rt2 <- Filter(gRTs,round2)
  stim2 <- Filter(gStim,round2)
  resp2 <- Filter(gResponded,round2)

  statserr1 <- SummaryStats(err1,stim1)
  statserr2 <- SummaryStats(err2,stim2)

  ##RT should only be aggregated for actual responses.

  rt1r <- Filter(rt1,resp1)
  stim1r <- Filter(stim1,resp1)

  rt2r <- Filter(rt2,resp2)
  stim2r <- Filter(stim2,resp2)

  statsrt1  <- SummaryStats(rt1r,stim1r)
  statsrt2  <- SummaryStats(rt2r,stim2r)

   FilePrint(gSumFileOut,"-----------------------------------------------")
   FilePrint(gSumFileOut,"PEBL Go-No-Go Task, Version 1.0")
   FilePrint(gSumFileOut,"http://pebl.sf.net")
   FilePrint(gSumFileOut,"Shane T. Mueller")
   FilePrint(gSumFileOut, GetPEBLVersion())
   FilePrint(gSumFileOut, GetSystemType())
   FilePrint(gSumFileOut, "Use mouse: " + gParams.usemouse)

   FilePrint(gSumFileOut,"-----------------------------------------------")
   FilePrint(gSumFileOut,"Screen width x height: " +gVideoWidth+ "x"+gVideoHeight)
   FilePrint(gSumFileOut, "Subject code: "+gSubNum)
   FilePrint(gSumFileOut, "Time:         "+TimeStamp())
   FilePrint(gSumFileOut,"-----------------------------------------------")

   FilePrint(gSumFileOut,"Total Correct:          "+Sum(Merge(err1,err2)))
   FilePrint(gSumFileOut,"Total Errors:           "+(Length(Merge(err1,err2))-Sum(Merge(err1,err2))))

   FilePrint(gSumFileOut,"Mean Accuracy:          "+(Mean(Merge(err1,err2))))
   FilePrint(gSumFileOut,"Mean Error:             "+(1-Mean(Merge(err1,err2))))
  FilePrint(gSumFileOut, "                 ROUND 1 Accuracy         ")
   FilePrint(gSumFileOut,"----------------------------------------")
   FilePrint(gSumFileOut,"Cond    N       median  mean    sd")
   FilePrint(gSumFileOut,"----------------------------------------")
   loop(i,statserr1)
    {
     tmp <- ""
      loop(j,i)
       {
         tmp <- tmp + Format(j,7) + " "
       }
      FilePrint(gSumFileOut,tmp)
     }
  FilePrint(gSumFileOut, "              ROUND 2 Accuracy rate")
   FilePrint(gSumFileOut,"----------------------------------------")
   FilePrint(gSumFileOut,"Cond    N       median  mean    sd")
   FilePrint(gSumFileOut,"----------------------------------------")
   loop(i,statserr2)
    {
     tmp <- ""
      loop(j,i)
       {
         tmp <- tmp + Format(j,7) + " "
       }
      FilePrint(gSumFileOut,tmp)
     }
   FilePrint(gSumFileOut,"----------------------------------------"+CR(2))

   FilePrint(gSumFileOut,"Round 1 Response time")
   FilePrint(gSumFileOut,"----------------------------------------")
   FilePrint(gSumFileOut,"Cond    N       median  mean    sd")
   FilePrint(gSumFileOut,"----------------------------------------")
   loop(i,statsrt1)
    {
     tmp <- ""
      loop(j,i)
       {
         tmp <- tmp + Format(j,7) + " "
       }
      FilePrint(gSumFileOut,tmp)
     }
   FilePrint(gSumFileOut,"----------------------------------------"+CR(2))

   FilePrint(gSumFileOut,"Round 2 Response time")
   FilePrint(gSumFileOut,"----------------------------------------")
   FilePrint(gSumFileOut,"Cond    N       median  mean    sd")
   FilePrint(gSumFileOut,"----------------------------------------")
   loop(i,statsrt2)
    {
     tmp <- ""
      loop(j,i)
       {
         tmp <- tmp + Format(j,7) + " "
       }
      FilePrint(gSumFileOut,tmp)
     }

  ##Save some coarse data to a pooled file, one line per subject.
   FilePrint_(gPooledSummary,gSubNum+","+TimeStamp()+","+GetTime() + "," +
       Sum(Merge(err1,err2))+","+(1-Mean(Merge(err1,err2)))+",")

 ## This output causes crashes when we have 0 error rates, etc.
 #  tmp <- Nth(Transpose(statserr1),4)
 #  FilePrint_(gPooledSummary,First(tmp)+","+Second(tmp))
 #  tmp <- Nth(Transpose(statserr2),4)
 #  FilePrint_(gPooledSummary,First(tmp)+","+Second(tmp))
 #  tmp <- Nth(Transpose(statsrt1),4)
 #  FilePrint_(gPooledSummary,First(tmp)+","+Second(tmp))
 #  tmp <- Nth(Transpose(statsrt2),4)
 #  FilePrint(gPooledSummary,First(tmp)+","+Second(tmp))

  settingsfile <- "/upload.json"
  #upload the following files:
  #gSumFileOut,gFileOut, gPooledFileOut (maybe not needed),gLog,gPooledSummary

  Print("uploading data")
  out <- UploadFile(gSubnum,gFileOut.filename,settingsfile);  Print(out)
  out <- UploadFile(gSubnum,gSumFileOut.filename,settingsfile);  Print(out)
  out <- UploadFile(gSubnum,gPooledFileOut.filename,settingsfile);  Print(out)
  out <- UploadFile(gSubnum,gLog.filename,settingsfile);  Print(out)
  out <- UploadFile(gSubnum,gPooledSummary.filename,settingsfile);  Print(out)


  ##Debrief at the end.
  MessageKeyBox(gDebrief)


}


define DoBlock(trials,correctresponse,type,col:"blue")
{
  ## Create the stimulus grid using shared function
  stimObjs <- CreateStimulusGrid(col, gLayout.centerX, gLayout.centerY)
  lines <- First(stimObjs)
  stars <- Second(stimObjs)
  xys <- Third(stimObjs)
  stim <- Fourth(stimObjs)

  ## Show header and subheader with clearer instructions
  gLayout.header.text <- SubstituteStrings(gStrings.header_respond_only, [["<TARG>", correctresponse]])
  gLayout.header.visible <- 1
  gLayout.subheader.visible <- 1

  ## Create feedback label at center
  feedback <- EasyLabel("X", gLayout.centerX, gLayout.centerY, gWin, 60)
  Hide(feedback)

  #Wait some unspecified duration
  timenow <- GetTime()
  timeend <- timenow
  trial <- 1
  totalTrials <- Length(trials)
  loop(i,trials)
  {
     ## Update subheader with method and trial counter
     gLayout.subheader.text <- gStrings.subheader_method + " [" + trial + "/" + totalTrials + "]"

     timeend <- timeEnd + gisi
     choice <- RandomDiscrete(4)
     xy <- Nth(xys,choice)
     Move(stim,Round(First(xy)),Round(Second(xy)))
     star <- Nth(stars,choice)
     Hide(star)
     stim.text <- i
     Show(stim)

     Draw()
     starttime <- GetTime()
     gStimOn <- 1
     ##make the stimulus disappear after 500 ms

      RegisterEvent("<TIMER>", 1, starttime+gParams.stimtime,"<GEQ>","HIDEME", [stim,star])

      ## Use Layout & Response System with spacebar mode
      ## Returns "response" or "<timeout>"
      resp <- WaitForLayoutResponse(gLayout, gParams.isi-50)

     endtime <- GetTime()
     HideMe(stim,star)
     ClearEventLoop()

     ## Check if response was made
     if(resp=="<timeout>")
        {
           resp <- "NONE"
           responded <- 0
        } else{
           ## Response was made (spacebar pressed) - give visual feedback
           responded <- 1
           ## Make label bold for 150ms as feedback
           gResponseLabel.font.bold <- 1  ## Make font bold
           Draw()
           RegisterEvent("<TIMER>", 1, GetTime()+150, "<GEQ>", "UnboldLabel", [])
        }


      if(i == correctresponse)
         {
            present <- 1
         } else {
            present <- 0
         }


       corr <- ((responded and (correctresponse==i)) or
               ((not responded) and (not (correctresponse==i))))

       ##Give feedback if this was practice.
	   if(type=="practice")
	   {
             if(corr==0)
             {
    	           Move(feedback,stim.x,stim.y)
		   Show(feedback)
		   Draw()
		   Wait(1000)
		   Hide(feedback)
		   Draw()
             }
           }



           outline <- gSubNum+","+gBlock+","+type+","+correctresponse+","+trial+","+choice+","+First(xy)+","+Second(xy)+","+i+","+present+","+resp+","+responded+","+corr+","+starttime + ","+(endtime-starttime)
	   FilePrint(gFileOut,outline)
	   FilePrint(gPooledFileOut,outline)
	   ##Append some data
	   gBlockNums <- Append(gBlockNums,gBlock)
	   gRTs	      <- Append(gRTs,(endtime-starttime))
	   gErrors    <- Append(gErrors, corr)
           gStim     <-  Append(gStim,i)
           gResponded <- Append(gResponded,responded)

	   trial<-trial + 1
	   WaitUntil(timeend)
 }


   RemoveObjects(stars,gWin)  ##these don't quite get cleaned up; maybe because of the
                              ##event-loop functions.
   ## Hide header/subheader after block
   gLayout.header.visible <- 0
   gLayout.subheader.visible <- 0
   Draw()
}


define AddObjects(list,win)
{
   loop(i,list)
    {
      AddObject(i,win)
    }
}



define GetStrings(lang)
{
##Known trasnlations: HR, EN, PT, ES
  gStrings <- GetTranslations("gonogo", lang)

   ## Use platform-independent method string
   method <- gStrings.method

   gLab <- method
   gInst1 <- SubstituteStrings(gStrings.inst1,
                [["<TARG>", gparams.pstim],
		 ["<FOIL>", gParams.rstim],
		 ["<METHOD>",method]])

   gInst2 <- SubstituteStrings(gStrings.inst2,
                 [["<METHOD>",method]])

   gInst3 <- SubstituteStrings(gStrings.inst3,
                [["<TARG>", gParams.pstim],
		 ["<FOIL>", gParams.rstim],
		 ["<METHOD>", method]])


   gDebrief <- gStrings.debrief

}


define MessageKeyBox(message)
{
  tb <- AdaptiveTextBox(message,100,100,gWin,24,gVideoWidth-200,gVideoHeight-200,"scalefont")
  Draw()

  ## Use Layout & Response System - spacebar mode accepts any spacebar press
  WaitForLayoutResponse(gLayout)

  RemoveObject(tb,gWin)
}

## Display instructions with example stimulus
## Cycles between target and foil every 2 seconds until spacebar is pressed
define ShowInstructions(message, targetLetter, foilLetter, color)
{
  ## Show compact instructions in header region only (textboxes positioned by upper-left corner)
  ## Keep height small (60px) to avoid overlapping with subheader
  instBox <- AdaptiveTextBox(message, 50, 10, gWin, 16, gVideoWidth-100, 60, "scalefont")

  ## Create example stimulus using shared function
  stimObjs <- CreateStimulusGrid(color, gLayout.centerX, gLayout.centerY)
  lines <- First(stimObjs)
  stars <- Second(stimObjs)
  xys <- Third(stimObjs)
  stimLabel <- Fourth(stimObjs)

  ## Position for letter (top-right quadrant, position 2)
  xy <- Nth(xys, 2)
  star <- Nth(stars, 2)

  ## Set up subheader for instructions (closer to stimulus than footer)
  gLayout.subheader.visible <- 1

  ## Cycle between target and foil every 2 seconds
  showingTarget <- 1
  lastSwitch <- GetTime()

  cont <- 1
  while(cont)
  {
    currentTime <- GetTime()

    ## Switch display every 2000ms
    if(currentTime - lastSwitch >= 2000)
    {
      showingTarget <- 1 - showingTarget
      lastSwitch <- currentTime
    }

    ## Update display based on current state
    if(showingTarget)
    {
      Hide(star)
      stimLabel.text <- targetLetter
      Move(stimLabel, Round(First(xy)), Round(Second(xy)))
      Show(stimLabel)
      gLayout.subheader.text <- gStrings.cue_respond
    } else {
      Hide(star)
      stimLabel.text <- foilLetter
      Move(stimLabel, Round(First(xy)), Round(Second(xy)))
      Show(stimLabel)
      gLayout.subheader.text <- gStrings.cue_dont_respond
    }

    Draw()

    resp <- WaitForLayoutResponse(gLayout, 1000)
    if(resp <> "<timeout>")
    {
      cont <- 0
    }
  }

  ## Clean up
  gLayout.subheader.visible <- 0
  RemoveObject(instBox, gWin)
  RemoveObjects(lines, gWin)
  RemoveObjects(stars, gWin)
  RemoveObject(stimLabel, gWin)
  Draw()
}


## Create stimulus grid with stars
## Returns [lines, stars, xys, stimLabel]
define CreateStimulusGrid(col, xCenter, yCenter)
{
  linecol <- MakeColor("darkgrey")
  color <- MakeColor(col)

  ## Calculate adaptive grid size based on available stimulus area
  ## Use the smaller of width/height to ensure grid fits, with margins
  availableWidth <- gLayout.stimulusRegion.width - 40   ## 20px margin on each side
  availableHeight <- gLayout.stimulusRegion.height - 40  ## 20px margin top/bottom
  maxSize <- Min([availableWidth, availableHeight])

  ## Grid extends from -sizegrid to +sizegrid, so divide by 2
  ## Default 200 means grid spans 400px total, so cap at that
  sizegrid <- Min([200, Round(maxSize / 2)])

  ## Create grid lines
  lines <- [ThickLine(xCenter-sizegrid, yCenter-sizegrid, xCenter+sizegrid, yCenter-sizegrid, 5, linecol)]
  lines <- Append(lines, ThickLine(xCenter-sizegrid, yCenter, xCenter+sizegrid, yCenter, 5, linecol))
  lines <- Append(lines, ThickLine(xCenter-sizegrid, yCenter+sizegrid, xCenter+sizegrid, yCenter+sizegrid, 5, linecol))

  lines <- Append(lines, ThickLine(xCenter-sizegrid, yCenter-sizegrid, xCenter-sizegrid, yCenter+sizegrid, 5, linecol))
  lines <- Append(lines, ThickLine(xCenter, yCenter-sizegrid, xCenter, yCenter+sizegrid, 5, linecol))
  lines <- Append(lines, ThickLine(xCenter+sizegrid, yCenter-sizegrid, xCenter+sizegrid, yCenter+sizegrid, 5, linecol))

  AddObjects(lines, gWin)

  ## Calculate star positions (4 quadrants)
  xs <- [xCenter-sizegrid/2, xCenter+sizegrid/2, xCenter-sizegrid/2, xCenter+sizegrid/2]
  ys <- [yCenter-sizegrid/2, yCenter-sizegrid/2, yCenter+sizegrid/2, yCenter+sizegrid/2]
  xys <- Transpose([xs, ys])

  ## Scale star and font sizes proportionally to grid size
  ## Base sizes: star outer=40, inner=20, font=40 for sizegrid=200
  scale <- sizegrid / 200.0
  starOuter <- Round(40 * scale)
  starInner <- Round(20 * scale)
  fontSize <- Round(40 * scale)

  ## Create stars
  stars <- []
  pts <- MakeStarPoints(starOuter, starInner, 6)
  loop(xy, xys)
  {
    shape <- Polygon(First(xy), Second(xy), First(pts), Second(pts), color, 1)
    AddObject(shape, gWin)
    shape.aa <- 1
    stars <- Append(stars, shape)
  }

  ## Create stimulus label (hidden initially) with scaled font size
  stim <- EasyLabel("", xCenter, yCenter, gWin, fontSize)
  Hide(stim)

  return([lines, stars, xys, stim])
}


define WaitUntil(time)
{

     RegisterEvent("<TIMER>", 1, time,"<GEQ>","", [])
     StartEventLoop()  #Start the timer
     ClearEventLoop()  #clear it out when done.

}

define HideMe(stim,star,evt:0)
{



  if(gStimOn)
  {

     Hide(stim)
     Show(star)
     gStimOn <- 0
     Draw()
  }

 return "<REMOVE>"
}


define UnboldLabel(evt:0)
{
  ## Callback to return label to normal style after visual feedback
  ## Guard condition prevents repeated execution - only unbold if currently bold
  if(gResponseLabel.font.bold != 0)
  {
      gResponseLabel.font.bold <- 0  ## Set to normal (not bold)
      Draw()
  }
  return "<REMOVE>"
}


define CollapseList (list)
{
  return ConcatenateList(list,"|")
}





define GetNewSubNum(server,page,port,username,pword)
{
   file <- page + "?user_name="+username+"&upload_password="+pword
   out <- GetHTTPText(server,port,file)
   if(First(out)==200)
    {
      subraw <- Second(out)
      len <- StringLength(subraw)

      sub <- SubString(Second(out),1,len-1)
    } else {
      sub <- RandomDiscrete(999999)

    }
    return sub
}




## UploadFile and SyncDataFile functions removed - using library versions from Utility.pbl
## These functions are auto-loaded and support both token and username/password authentication
