## PEBL Cognitive Assessment Screening
##
##  Patterned after common cognitive screening tests, including MMSE, MOCA,
## SLUMS, AMTS, GPAC, etc.
 

define Start(p)
{

  gWin <- MakeWindow()
  if(gSubnum +"" =="0")
  {
    gSubNum <-  GetSubNum(gWin)
   }
  gPage <- 1



  ##set default parameter values, in case .par file does not exist
  parpairs <- [["doTrails",0],  
               ["doCube",1],
	       ["doClock",0],
	       ["doMemory",0],
	       ["doShape",0],	       
	       ["doNaming",0],
	       ["doSerialRecall",0],
	       ["doGoNoGo",0],
	       ["doSentenceVerification",0],
	       ["doSemanticOddball",0],
	       ["doSerialSubtraction",0],
	       ["doStemCompletion",0],
	       ["stemCompletionRule","f"],
	       ["doOrientation",0],
	       ["useRandom",0],
	       ["savescreenshots",0],
	       ["doAudioHelp",0]]
	       
  gParams <- CreateParameters(parpairs,gParamFile)

 totalScore <- []
 startTime <- GetTime()
 
 MakeDirectory("data")
 fileOutData <- GetNewDataFile(gSubNum,gWin,"spatialdrawing","csv",
                  "")

 fileHTMLReport <- GetNewDataFile(gSubNum,gWin,"spatialdrawing","html", "")


##pool data here.

 FilePrint(fileHTMLReport,PageHead())







if(gParams.doCube)
{
  cubeDat <- DrawCubeTest()
  PushOnEnd(totalScore,["cube",First(cubeDat),1,TimeStamp()])
  FilePrint(fileHTMLReport, HTMLCubeOutput(cubeDat))
}





##end it all
 totalTime <- GetTime() - starttime
 scores <- Transpose(totalScore)
 header <- ["Task","Points","Max","Time completed"]

  outcsv <-""
loop(i,totalscore)
{
 line <- Merge([gSubnum],i)
 outcsv <- outcsv + ConcatenateList(line,",")+CR(1)
}

FilePrint(fileOutData,outcsv)
FileClose(fileOutData)

FilePrint( fileHTMLReport,PageEnd([header,totalscore],
                          Sum(Second(scores)),Sum(Third(scores)),
                          totalTime))


  MessageBox("Thank you. You have completed the screening. Your data report is avaliable in the file" + fileHTMLReport.filename + " which will open up when you hit OK",
   gWin)
   
   FileClose(fileHTMLReport)
   Launchfile(fileHTMLReport.filename)
}


####################################
####################################
## Code for trails subtest

define TrailsTest()
{



  gStimColor <- MakeColor("gold")
  gAccentColor <- MakeColor("grey35")
  gstimFont <-  MakeFont(gPEBLBaseFontMono,0,18,MakeColor("black"),gStimColor,0)
  gReversedFont <-  MakeFont(gPEBLBaseFontMono,0,22,gStimColor,MakeColor("black"),0)
  gclickedFont <- MakeFont(gPEBLBaseFontMono,1,18,MakeColor("grey35"),gStimColor,0)

   strings <-    ReadTranslationJSON("translations/"+Uppercase(gLanguage)+"/trails.json",gLanguage)

   DoInstructions(strings.taskname,
                  strings.longinst,
		  "translations/"+Uppercase(gLanguage)+"/"+strings.longinstimage,
		  "translations/"+Uppercase(gLanguage)+"/"+strings.longinstsound)


   targets <- ["1","A","2","B","3","C","4","D","5","E"]

   startTime <- GetTime()

   inst1 <- MakeHeader(strings.inst1,  gVideoWidth/2,100,gWin,28)
   inst2 <- MakeHeader(strings.inst2,  gVideoWidth/2,150,gWin,22)

   xmin <- gVideoWidth/2-300
   xmax <- gVideoWidth/2+300
   ymin <- gVideoHeight/2-300
   ymax <- gVideoHeight/2+300


   
   #pts <- NonOverlapLayout(xmin,xmax,ymin, ymax, 20,10)
   pts <-    [[728, 519],  [731, 305],
               [1133, 310],  [810, 342],
 	       [968, 363],  [1044, 485],
               [1240, 649],  [940, 530],
	       [730, 746], [1210, 785]]

   ##adjust pts to center.
   tp <- Transpose(pts)
   xs <- First(tp)
   ys <- Second(tp)

   xs <- VecSum(xs, Repeat(xmin-Min(xs),Length(xs)))
   ys <- VecSum(ys, Repeat(xmin-Min(ys),Length(ys)))
   Print(xs)
   Print(ys)
   pts <- Transpose([xs,ys])

    pt1 <- First(pts)
    pt2 <- Second(pts)
    pt3 <- ThirD(pts)
    line1 <- ThickLine(First(pt1),Second(pt1),First(pt2),Second(pt2),10,gAccentColor)
    line2 <- ThickLine(First(pt2),Second(pt2),First(pt3),Second(pt3),10,gAccentColor)
    AddObject(line1,gWin)
    AddObject(line2,gWin)
    
    stimObjects <-  PlotTargets(pts,25,targets)

   stimLines <- []

   firstpt <- First(stimObjects)
   lastpt <- Last(stimObjects)
   startLabel <- MakeLabel(strings.begin,gReversedFont)
   AddObject(startLabel,gWin)
   Move(startLabel ,firstpt.x,firstpt.y+40)

   endLabel <- MakeLabel(strings.end, gReversedFont)

   AddObject(endLabel,gWin)
   Move(endLabel,   lastpt.x,lastpt.y+40)
   prev <- First(stimObjects)
   remaining <- Rest(stimObjects)

   Draw()



   #force clicking on the target 1 first
   WaitForClickOnTarget([firstpt],[1])
   targ <-   firstpt.circle2
   targ.color <- gAccentColor
   Draw()   
   startTime <- GetTime()   
   ids <- []
   

   cont <- 1
   while(cont)
    {

      Draw()
      id <- WaitForClickOnTarget(remaining,Sequence(1,Length(remaining),1))




     clickedOn <- Nth(remaining,id)

     targ <-   clickedOn.circle2
     targ.color <- gAccentColor
     numclicked <- clickedon.value
     
   if(numClicked <> prev.value)
   {
      PushOnEnd(ids,id)
     
      ##draw the line
      x0 <- prev.x
      y0 <- prev.y
      x1 <- clickedOn.x
      y1 <- clickedOn.y



      l <- ThickLine(x0,y0,x1,y1,5,gStimColor)
      PushOnEnd(stimLines,l)
      AddObject(l,gWin)
      AddObjects(stimObjects,gWin) ##move to top.
      prev <- clickedOn
    }

    if(clickedOn.value == "E")
    {
      cont <- 0
    }
  
   }

   inst1.text <- strings.complete
   inst2.text <- strings.continue
   Draw()

   if(gParams.savescreenshots)
   {
      range <- [xmin-50,ymin-50,xmax-xmin+100,ymax-ymin+100]
      Print(range)
      range <- [0,0,gVideoWidth,gVideoHeight]
      WritePNG("data/"+gSubnum+"/trails.png",gWin,range)
             
   }
   WaitForDownClick()


   corrects <- 0
   errors <- 0
   counter <- 1
   loop(i,ids)
   {
     #Print("Scoring: " + i + " <--> " + counter)
     corrects <- corrects + (i == counter)
     errors <- errors + (i <> counter)
     counter <- counter + 1
   }
  
   score <- (corrects== 9) and (errors == 0)

   #Print("Trails task: " + score  + " " + corrects + "  " + errors)
   return [score,corrects,errors, (GetTime()-startTime)]

}


define PlotTargets(pts,size,labels)
{



  comp <- []
  highlighted <- Repeat(1,Length(pts))
  tmp <- Transpose([pts,labels,highlighted])
  loop(i,tmp)
   {
      pos <- First(i)
      label <- Nth(i,2)
      highlight <- Nth(i,3)
      comp <- Append(comp,  AddTarget(pos,label,size,highlight))
   
   }
 return comp
}



define AddObjects(oblist,win)
{
 loop(i,oblist)
 {
    AddObject(i,win)
 }
}



define AddTarget(pos,letter,size,clicked)
{

    ##if type== 1, add an accented circle around the target.

   x <- First(pos)
   y <- Nth(pos,2)

   if(clicked)
    {
       crc1 <- Circle(x,y,size+5,gAccentColor,1)
       crc2 <- Circle(x,y,size,gStimColor,1)
       crc1.aa <- 1
       crc2.aa <- 1

    } else {

       crc1 <- Circle(x,y,size,gStimColor,1)  ##accent in teh same color
       crc2 <- Circle(x,y,size,gStimColor,1)
       crc1.aa <- 1
       crc2.aa <- 1

    }


    AddObject(crc1,gWin)
    AddObject(crc2,gWin)
    lab <- MakeLabel(letter+"",gstimFont)
    AddObject(lab,gWin)
    Move(lab,x,y)

   obj <- MakeCustomObject("target")
   obj.x <- x
   obj.y <- y
   obj.radius <- size
   obj.value <- letter
   obj.circle1 <- crc1
   obj.circle2 <- crc2
   obj.label <- lab
   obj.clicked <- clicked
   obj.inside <- "INSIDECIRCLE"
   obj.addobject <- "ADDCIRCLE"
   return obj
}


define AddCircle(obj,win)
{
   AddObject(obj.circle1,win)
   AddObject(obj.circle2,win)
   AddObject(obj.label,win)
}

define InsideCircle(xy,obj)
{
    inside <- 0
   if( Sqrt( (obj.x-First(xy))^2 + (obj.y - Second(xy))^2) <= obj.radius)
   {
     inside <- 1
   }

  return inside
}


define DrawPath(path,pts)
{


      ##Path is a sequence of targets
      ##pts is a list of [x,y] points

      pts2 <- SortBy(pts,Order(path))
      last <- Last(pts2)
      stimObjects <- []


      loop(i,pts2)
       {

        x0 <- First(last)
        y0 <- Nth(last,2)

        xdiff <- First(i) - x0
        ydiff <- Nth(i,2) - y0
        l <- Line(First(last),Nth(last,2),xdiff,ydiff,gStimColor)
#        l <- ThickLine(First(last),Second(last),x0,y0,4,gStimColor)
        AddObject(l,gWin)
        stimObjects <- Append(stimObjects,l)
        last <- i
       }

  return stimObjects
}

define HTMLTrailsOutput(dat)
{

  out <- HL()+H("PCST Trails Test",2) +Hl()+
        P(Timestamp())+
        P( B("Points earned (out of 1): ")+ First(dat))+
	P( B("Correct clicks:           ")+ Second(dat))+
	P( B("Error clicks:             ")+ Third(dat)) +
	P( B("Time taken:               ") +Round(Fourth(dat)/1000,2) + " sec")

   if(gParams.savescreenshots)
       {
         out <- out + Img("trails.png",600)
       }
  return MakeDivPage(out )
}


##############################################################
##############################################################
## Copy-cube subtest.

## The goal is to copy a 'necker' cube, but permit it to be done simply
## with a mouse.


define DrawCubeTest ()
{
   strings <-    ReadTranslationJSON("translations/"+Uppercase(gLanguage)+"/cube.json",gLanguage)

   DoInstructions(strings.taskname,
                  strings.longinst,
		  "translations/"+Uppercase(gLanguage)+"/"+strings.longinstimage,
		  "translations/"+Uppercase(gLanguage)+"/"+strings.longinstsound)

  inst1 <- MakeHeader(strings.inst1,gVideoWidth/2,100,gWin,28)
  inst2 <- MakeHeader(strings.inst2,gVideoWidth/2,150,gWin,22)

  buttonColor <- MakeColor("gold")
  
  standard <- MakeGrid(gWin,10,10,200,600,200,600,"black")
  theGrid <- MakeGrid(gWin,10,10,800,1200,200,600,"grey30")


   deleteButton <- Rectangle(850,700,200,50,buttonColor,1)
   AddObject(deleteButton,gWin)
   deleteLabel <- Easylabel(strings.delete,deleteButton.x,deleteButton.y,gWin,25,"grey20")


   okButton <- Rectangle(1150,700,200,50,buttonColor,1)
   AddObject(okButton,gWin)
   okLabel <- Easylabel(strings.ok,okButton.x,okButton.y,gWin,25,"grey20")







  points  <- theGrid.points
  indexes <- theGrid.indexes
  ids <- Sequence(1,Length(points),1)
  startTime <- GetTime()
  Draw()



  ## classic cube:
   diagram <- [[3,10],[10,80],[80,73],[73,3],
               [21,28],[28,98],[98,91],[91,21],
	       [3,21],[10,28],[80,98],[73,91]]


 
    diagram <- [[71, 93], [93, 6], [6, 20], [20, 97], [71, 6], [93, 97], [20, 85], [85, 97], [85, 71]]


newDiagram <- []


   standard <-   DrawSketch(diagram,standard,MakeColor("grey40"))
   Draw()
   cont <- 1
   clickons <- Merge(thegrid.points,[okButton,deleteButton])
   ident <- Merge(ids,["OK","DEL"])

   edits <- 0
   startTime <- GetTime()
   
   while(cont)
   {
      ##get start of line
      start <- WaitForClickOnTarget(clickOns,ident)
      edits <- edits + 1
     if(start == "DEL")
     {
       if(Length(newDiagram) <= 1)
       {
        newDiagram <- []
       } else{
       
          newDiagram <- SubList(newDiagram,1,Max([1,Length(newDiagram)-1]))
       }
       out <- DrawSketch(newDiagram,theGrid,MakeColor("grey60"))
       
     }elseif( start == "OK")
     {
       cont <- 0
     } else {
       ##start is the index number

      targ <- Nth(thegrid.points,start)
      circ1 <- Circle(targ.x,targ.y,14,MakeColor("yellow"),1)
      AddObject(circ1,gWin)
      Draw()

      end <- WaitForClickOnTarget(clickOns,ident)
     if(end == "DEL")
     {
      #no-op
     }elseif( end == "OK")
     {
       cont <- 0
     } else {
       ##end is the index number

      targ2 <- Nth(thegrid.points,end)
      circ2 <- Circle(targ2.x,targ2.y,14,MakeColor("yellow"),1)
      AddObject(circ2,gWin)
      Draw()
      Wait(50)
      RemoveObject(circ1,gWin)
      RemoveObject(circ2,gWin)

      if(start <> end)
      {
        PushOnEnd(newDiagram,[start,end])
      }
      out <- DrawSketch(newDiagram,theGrid,MakeColor("grey60"))
     }
   }
   Draw()
  }
  time <- GetTime()

   inst1.text <- strings.complete
   inst2.text <- strings.continue
   Draw()
   WaitForDownClick()
   if(gParams.savescreenshots)
   {

      range <- [theGrid.xmin-100,thegrid.ymin-150,thegrid.xmax-thegrid.xmin+200,thegrid.ymax-thegrid.ymin+300]
      WritePNG("data/"+gSubnum+"/cube.png",gWin, range)
   }

  Print(newdiagram)
  score <- ScoreCube(diagram, newdiagram)

  return Append(score,GetTime()-starttime)
}

##Add 
define DrawSketch(sketch,bg,color)
{
  lines <- []
  
  loop(i,sketch)
  {   
  
      startindex <- Nth(bg.indexes,First(i))
      startx <- bg.xmin + bg.xDelta * (First(startIndex)-1)
      starty <- bg.ymin + bg.yDelta * (Second(startIndex)-1)
      
      endindex <- Nth(bg.indexes,Second(i))
      endx <- bg.xmin + bg.xDelta * (First(endIndex)-1)
      endy <- bg.ymin + bg.yDelta * (Second(endIndex)-1)
      
#     Print(startindex + " to " + endindex + ": " + startx+","+starty + "-->"+  endx + "," + endy)
   
    line <-  ThickLine(startx,starty,endx,endy,3,color)
    AddObject(line,bg.win)
    PushOnEnd(lines,line)
  }

  return lines
}



define MakeGrid(win,width,height,xmin,xmax,ymin,ymax,color:"grey")
{

  col <- MakeColor(color)
  xDelta <- (xmax - xmin)/ (width-1)
  yDelta <- (ymax - ymin)/ (height-1)
  
  points <- []
  coords <- []
  loop(i,height)
  {
    loop(j,width)
    {
       point <- Circle(xmin  + xDelta * (i-1),ymin + yDelta * (j-1), 15,col,0)
       AddObject(point,win)
       PushOnEnd(points,point)
       PushOnEnd(coords,[i,j])
		       
    }
  }


  theGrid <- MakeCustomObject("grid")
  theGrid.points <- points
  theGrid.indexes <- coords
  theGrid.xmin <- xmin
  theGrid.xmax <- xmax
  theGrid.ymin <- ymin
  theGrid.ymax <- ymax
  theGrid.xdelta <- xDelta
  theGrid.ydelta <- yDelta
  theGrid.width <- width
  theGrid.height <- height
  theGrid.win <- win
  return (theGrid)
}


define ScoreCube(standard,answer)
{

  ##first, sort each of these.

  stand2 <- []
  loop(i,standard)
  {
    sorted <- Sort(i)
    PushonEnd(stand2,First(sorted) + "-" + Second(sorted))
  }


  ans2 <- []
  loop(i,answer)
  {
    sorted <- Sort(i)
    PushonEnd(ans2,First(sorted) + "-" + Second(sorted))
  }


 ## now, identify matches and mismatches.


 matches <- []
 nonmatches <- []
 loop(i,stand2)
 {
   if(IsMember(i,ans2))
   {
    PushOnEnd(matches,i)
   } else {
    PushOnEnd(nonmatches,i)
   }

  ##filter that matches what we just found.
  removematches <- Match(Match(ans2,i),0)  ##reverses matches
  
  ans2 <- Filter(ans2,removematches)
  
 }

  matchscore <-  Length(matches)
  nonmatchscore <- Length(nonmatches)
  missing <- Length(ans2)


  score <-  0+ ((matchscore - nonmatchscore - missing )==Length(standard))
  return ( [score,matchscore,nonmatchscore,missing])
}



define HTMLCubeOutput(dat)
{

  out <- HL()+H("PCST Cube-drawing Test",2) +Hl()+
        P(Timestamp())+
        P( B("Points earned (out of 1): ") + First(dat))+
	P( B("Matched lines:            ") + Second(dat))+
	P( B("Missing lines :           ") + Third(dat)) +
        P( B("Extra lines :             ") + Fourth(dat)) +
	P( B("Time taken:               ") +Round(Fifth(dat)/1000,2) + " sec")
	
   if(gParams.savescreenshots)
       {
         out <- out + Img("cube.png",300)
       }

  return MakeDivPage(out)
}




define Tabulize (list)
{
  tmp <- ""
   loop(i,list)
   {
     tmp <- tmp + i+ "    "
   }
   return tmp
}





define DoInstructions(title,text,image,soundfile)
{
  ##The text should be in a panel on the top.
  ## the image should be no bigger than 800 x 600, and will be centered on the bottom.
  ## the sound file will be optional, but will play automatically.


  headerFont <-  MakeFont(gPEBLBaseFontMono,0,30,MakeColor("gold"),MakeColor("black"),0)
  textFont   <- MakeFont(gPEBLBaseFontMono,0,22,MakeColor("grey90"),MakeColor("black"),0)

  lab <- MakeLabel(title,headerFont)
  Addobject(lab,gWin)
  Move(lab,gVideoWidth/2,50)
  text <- MakeTextBox(text,textFont,800,300)
  AddObject(text,gWin)
  Move(text,(gVideoWidth-800)/2,100)

 if(FileExists(image))
  {
    imageMaxHeight <-( gVideoHeight-(text.y+text.height))-100
    img <- MakeImage(image)

  scale <-imageMaxHeight / img.height
  if(scale<.9)
   {
    img.zoomX <- scale
    img.zoomY <- scale
    }
  AddObject(img,gWin)
  Move(img,gVideoWidth/2, 400 + img.height/2)
  }
  Draw()
  
  if(FileExists(soundfile) and gParams.doAudioHelp)
  {

    sound <- LoadSound(soundfile)
    PlayForeground(sound)
  }

  WaitForDownClick()

}


## Basic HTML report creation helpers
##
##

define OT(tag)
{
  return "<"+tag+">"
}

define CT(tag)
{
 return "</"+tag+">"
}

define H(text,level)
{
  tag <- "h"+level
  return OT(tag) + text + CT(tag)
}

define P(text)
{
  return OT("p") + text + CT("p")
}

define B(text)
{
 return "<b>"+text+"</b>"+CR(1)
}
define BR()
{
 return "<br>"
}
define HL()
{
  return "<hl>"
}

define Img(filename,width)
{
  return "<img src='"+filename+"' width="+width+"/>"
}
define PageHead()
{
 out <-  "<html>
<head>
  <link rel='stylesheet' href='../../paper.css'>

</head>
<body>"+
#<a href='#' onclick='window.print();return false;' title='Click to print this page'>Print this page</a>" +
 MakeDivPage(" <h1>Results from PEBL Cognitive Screening Test</h1>
   <pre>Participant/Patient Code: "+gSubNum+"</pre>
   <em>This test intended for screening for mild cognitive impairment.  It is not intended for self-diagnosis by untrained users. This test is inspired by tests included in commercial screening tests like the Montreal Cognitive Assessment and the Mini-mental state exam, but is developed independently.</em>
  <hl>
  <p><b>Test began:</b>  "+TimeStamp()+"</p>")

  return out
}

define PageEnd(scoretab,score,max,time)
{



   out <-H("Summary of PCST Test:",1) +
   Table(Second(scoreTab),First(scoretab))+

   P(B("Total score recorded on test: " ) +score + " of " + max )+
   P(B("Time to complete test:        " ) +Round(time/60000,2) + " min" )
   out <- MakeDivPage(out) + "</body></html>"


   return  out 
}
define Page(text)
{
  return     "<html><header></header><body> " + text +"</body></html>"
           
}

define Entag(tag,body)
{
  return OT(tag)+body+CT(tag)
}

define Table(tab,header:"")
{

 out <-   OT("table class='fl-table'")

if(IsList(header))
 {
   out <- out + "<thead><tr>"
   loop(item,header)
   {
     out <- out + "<th>"+item+"</th>"
   } 
   out <- out + "</tr></thead>"+CR(1)
 }

 loop(rowlist,tab)
 {
    row <- ""
    if(IsList(rowlist))
    {
      loop(item,rowlist)
      {
        row <- row +  Entag("td",item)
      }
    }
    out <- out + Entag("tr",row)
 }
 out <- out +   CT("table")

 return out
}



define ListMatches(l1,l2)
{
  
  high <- Max([Length(l1),Length(l2)])
  low <-  Min([Length(l1),Length(l2)])
  if(low == 0)
  {
    eql <- []
  } else{
  
  eql <- Repeat(0,high)
    
   loop(i,low)
    {
      Print(Nth(l1,i)+"=="+Nth(l2,i)+"?  " + ((Nth(l1,i)+"")==Nth(l2,i)+""))
      SetElement(eql,i,(Nth(l1,i)+"")==(Nth(l2,i)+""))
      Print(eql)
    }
   }
  return eql
}

define MakeDivPage(text)
{
  out <- "<div class='page'><div class='subpage'><p align='right'> Page " + gPage + " </p>"+
         text + "</div></div>"
  gPage <- gPage + 1

  return out
}


define WaitForDownClickWithTimeout(delay)
{
   endTime <- GetTime()+delay
   end <- 0
   left <- delay
   while(not end)
   {
      
      out <- WaitForMouseButtonWithTimeout(left)
      if(IsList(out))
      {
        end <- (Fourth(out)=="<pressed>")
	left <- endTime - GetTime()
      }else{
        end <- 1 ##timeout!
      }
   }
   return out
}


define ReadTranslationJSON(filename,lang)
{

  if(not FileExists(filename))
  {
    SignalFatalError("No translation file exists for ["+lang+"] ("+
      filename +")")
  }

  obj <- ParseJSON(FileReadText(filename))
  obj.language <- Lowercase(lang)

#PrintProperties(obj)
##we need to transform using formattext now.
 proplist <- GetPropertyList(obj)
 loop(prop,proplist)
 {
   if(IsText(GetProperty(obj,prop)))
   {
     text <- FormatText(GetProperty(obj,prop))
     SetProperty(obj,prop,FormatText(GetProperty(obj,prop)))
   }
 }

  return obj
}


##This makes a header label at the base font size, but scales down if it is too wide for the window.
define MakeHeader(text,x,y,window,size,maxwidth:0)
{ 

  if(maxwidth==0)
  {
   maxwidth <- window.width-25
  }

  itfits <- 0
  cursize <- size
  while(not itfits)
  {
      testlabel <- EasyLabel(text,x,y,window,cursize)

    if(testlabel.width > maxwidth)
    {
     cursize <- Max([5,cursize - 1])
    }else{
     itfits <- 1
    } 
  }

 return testlabel
}